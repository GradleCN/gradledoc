<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Dependency Management - Gradle User Guide Version 3.2</title><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="base.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="docs.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="userguide.css"><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"><link rel="home" href="userguide.html" title="Gradle User Guide Version 3.2"><link rel="up" href="pt03.html" title="Part&nbsp;III.&nbsp;Writing Gradle build scripts"><link rel="prev" href="logging.html" title="Logging - Gradle User Guide Version 3.2"><link rel="next" href="multi_project_builds.html" title="Multi-project Builds - Gradle User Guide Version 3.2"></head><body><div class="navheader"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="logging.html" title="Logging - Gradle User Guide Version 3.2">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide Version 3.2">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="multi_project_builds.html" title="Multi-project Builds - Gradle User Guide Version 3.2">Next</a></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 xmlns:xslthl="http://xslthl.sf.net"><a name="dependency_management"></a>Chapter&nbsp;24.&nbsp;Dependency Management</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="dependency_management.html#sec:Introduction">24.1. Introduction</a></span></dt><dt><span class="section"><a href="dependency_management.html#sec:dependency_management_overview">24.2. Dependency Management Best Practices</a></span></dt><dt><span class="section"><a href="dependency_management.html#sub:configurations">24.3. Dependency configurations</a></span></dt><dt><span class="section"><a href="dependency_management.html#sec:how_to_declare_your_dependencies">24.4. How to declare your dependencies</a></span></dt><dt><span class="section"><a href="dependency_management.html#sec:working_with_dependencies">24.5. Working with dependencies</a></span></dt><dt><span class="section"><a href="dependency_management.html#sec:repositories">24.6. Repositories</a></span></dt><dt><span class="section"><a href="dependency_management.html#sec:dependency_resolution">24.7. How dependency resolution works</a></span></dt><dt><span class="section"><a href="dependency_management.html#sec:finetuning_the_dependency_resolution_process">24.8. Fine-tuning the dependency resolution process</a></span></dt><dt><span class="section"><a href="dependency_management.html#sec:dependency_cache">24.9. The dependency cache</a></span></dt><dt><span class="section"><a href="dependency_management.html#sec:strategies_of_transitive_dependency_management">24.10. Strategies for transitive dependency management</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:Introduction" class="section-anchor" href="#sec:Introduction"></a>24.1.&nbsp;Introduction</h2></div></div></div><p>Dependency management is a critical feature of every build, and Gradle has placed an emphasis on offering first-class dependency management that is both easy to understand and
            compatible with a wide variety of approaches. If you are familiar with the approach used by either Maven or Ivy you will be delighted to learn that Gradle is fully compatible with both
            approaches in addition to being flexible enough to support fully-customized approaches.
        </p><p>Here are the major highlights of Gradle's support for dependency management:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Transitive dependency management</em></span>: Gradle gives you full control of your project's dependency tree.
                </p></li><li class="listitem"><p><span class="emphasis"><em>Support for non-managed dependencies</em></span>: If your dependencies are simply files in version control or a shared drive, Gradle provides powerful functionality
                    to support this.
                </p></li><li class="listitem"><p><span class="emphasis"><em>Support for custom dependency definitions.</em></span>: Gradle's Module Dependencies give you the ability to describe the dependency hierarchy in the build script.
                </p></li><li class="listitem"><p><span class="emphasis"><em>A fully customizable approach to Dependency Resolution</em></span>: Gradle provides you with the ability to customize resolution rules making dependency substitution
                    easy.
                </p></li><li class="listitem"><p><span class="emphasis"><em>Full Compatibility with Maven and Ivy</em></span>: If you have defined dependencies in a Maven POM or an Ivy file, Gradle provides seamless integration with a range of
                    popular build tools.
                </p></li><li class="listitem"><p><span class="emphasis"><em>Integration with existing dependency management infrastructure</em></span>: Gradle is compatible with both Maven and Ivy repositories. If you use Archiva, Nexus, or
                    Artifactory, Gradle is 100% compatible with all repository formats.
                </p></li></ul></div><p>
            With hundreds of thousands of interdependent open source components each with a range of versions and incompatibilities, dependency management has a habit of causing problems as builds
            grow in complexity. When a build's dependency tree becomes unwieldy, your build tool shouldn't force you to adopt a single, inflexible approach to dependency management. A proper build
            system has to be designed to be flexible, and Gradle can handle any situation.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:dependency_management_and_migrations" class="section-anchor" href="#sub:dependency_management_and_migrations"></a>24.1.1.&nbsp;Flexible dependency management for migrations</h3></div></div></div><p>
                Dependency management can be particularly challenging during a migration from one build system to another. If you are migrating from a tool like Ant or Maven to Gradle, you may be
                faced with some difficult situations. For example, one common pattern is an Ant project with version-less jar files stored in the filesystem. Other build systems require a wholesale
                replacement of this approach before migrating. With Gradle, you can adapt your new build to any existing source of dependencies or dependency metadata. This makes incremental migration
                to Gradle much easier than the alternative. On most large projects, build migrations and any change to development process is incremental because most organizations can't afford to
                stop everything and migrate to a build tool's idea of dependency management.
            </p><p>Even if your project is using a custom dependency management system or something like an Eclipse .classpath file as master data for dependency management, it is very easy to write a
                Gradle plugin to use this data in Gradle. For migration purposes this is a common technique with Gradle. (But, once you've migrated, it might be a good idea to move away from a
                .classpath file and use Gradle's dependency management features directly.)
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:dependency_management_and_java" class="section-anchor" href="#sub:dependency_management_and_java"></a>24.1.2.&nbsp;Dependency management and Java</h3></div></div></div><p>It is ironic that in a language known for its rich library of open source components that Java has no concept of libraries or versions. In Java, there is no standard way to tell the
                JVM that you are using version 3.0.5 of Hibernate, and there is no standard way to say that
                <code class="literal">foo-1.0.jar</code>
                depends on <code class="literal">bar-2.0.jar</code>. This has led to external solutions often based on build tools. The most popular ones at the moment are Maven and Ivy. While Maven provides a
                complete build system, Ivy focuses solely on dependency management.
            </p><p>Both tools rely on descriptor XML files, which contain information about the dependencies of a particular jar. Both also use repositories where the actual jars are placed together
                with their descriptor files, and both offer resolution for conflicting jar versions in one form or the other. Both have emerged as standards for solving dependency conflicts, and while
                Gradle originally used Ivy under the hood for its dependency management. Gradle has replaced this direct dependency on Ivy with a native Gradle dependency resolution engine which
                supports a range of approaches to dependency resolution including both POM and Ivy descriptor files.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:dependency_management_overview" class="section-anchor" href="#sec:dependency_management_overview"></a>24.2.&nbsp;Dependency Management Best Practices</h2></div></div></div><p>While Gradle has strong opinions on dependency management, the tool gives you a choice between two
            options: follow recommended best practices or support any kind of pattern you can think of. This section
            outlines the Gradle project's recommended best practices for managing dependencies.
        </p><p>No matter what the language, proper dependency management is important for every project.
            From a complex enterprise application written in Java depending on hundreds of open source
            libraries to the simplest Clojure application depending on a handful of libraries, approaches to dependency
            management vary widely and can depend on the target technology, the method of application deployment, and the
            nature of the project. Projects bundled as reusable libraries may have different requirements than
            enterprise applications integrated into much larger systems of software and infrastructure. Despite this wide variation of requirements,
            the Gradle project recommends that all projects follow this set of core rules:
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:versioning_the_jar_name" class="section-anchor" href="#sub:versioning_the_jar_name"></a>24.2.1.&nbsp;Put the Version in the Filename (Version the jar)</h3></div></div></div><p>The version of a library must be part of the filename. While the version of a jar is usually in the Manifest file, it isn't readily apparent when you are inspecting a
                project. If someone asks you to look at a collection of 20 jar files, which would you prefer? A collection of files with names like <code class="filename">commons-beanutils-1.3.jar</code>
                or a collection of files with names like <code class="filename">spring.jar</code>? If dependencies have file names with version numbers you can quickly identify the versions of
                your dependencies.
            </p><p>If versions are unclear you can introduce subtle bugs which are very hard to find. For example there might be a project which uses Hibernate 2.5. Think about a developer who decides
                to install version 3.0.5 of Hibernate on her machine to fix a critical security bug but forgets to notify others in the team of this change. She may address the security bug
                successfully, but she also may have introduced subtle bugs into a codebase that was using a now-deprecated feature from Hibernate. Weeks later there is an exception on the integration
                machine which can't be reproduced on anyone's machine. Multiple developers then spend days on this issue only finally realising that the error would have been easy to uncover if they knew
                that Hibernate had been upgraded from 2.5 to 3.0.5.
            </p><p>Versions in jar names increase the expressiveness of your project and make them easier to maintain. This practice also reduces the potential for error.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:transitive_dependency_management" class="section-anchor" href="#sub:transitive_dependency_management"></a>24.2.2.&nbsp;Manage transitive dependencies</h3></div></div></div><p>Transitive dependency management is a technique that enables your project to depend on libraries which, in turn, depend on other libraries. This recursive pattern of transitive
                dependencies results in a tree of dependencies including your project's first-level dependencies, second-level dependencies, and so on. If you don't model your dependencies as a
                hierarchical tree of first-level and second-level dependencies it is very easy to quickly lose control over an assembled mess of unstructured dependencies. Consider the Gradle project
                itself, while Gradle only has a few direct, first-level dependencies, when Gradle is compiled it needs more than one hundred dependencies on the classpath. On a far larger scale,
                Enterprise projects using Spring, Hibernate, and other libraries, alongside hundreds or thousands of internal projects, can result in very large dependency trees.
            </p><p>When these large dependency trees need to change, you'll often have to solve some dependency version conflicts. Say one open source library needs one version of a logging library and
                a another uses an alternative version. Gradle and other build tools all have the ability to resolve conflicts, but what differentiates Gradle is the
                control it gives you over transitive dependencies and conflict resolution.
            </p><p>While you could try to manage this problem manually, you will quickly find that this approach doesn't scale. If you want to get rid of a first level dependency you really can't be
                sure which other jars you should remove. A dependency of a first level dependency might also be a first level dependency itself, or it might be a transitive dependency of yet another
                first level dependency. If you try to manage transitive dependencies yourself, the end of the story is that your build becomes brittle: no one dares to change your dependencies because
                the risk of breaking the build is too high. The project classpath becomes a complete mess, and, if a classpath problem arises, hell on earth invites you for a ride.
            </p><div class="note"><span class="emphasis"><em>NOTE:</em></span>In one project, we found a mystery LDAP related jar in the classpath. No code referenced this jar and there was no connection to the project. No one could
                figure out what the jar was for, until it was removed from the build and the application suffered massive performance problems whenever it attempted to authenticate to LDAP. This
                mystery jar was a necessary transitive, fourth-level dependency that was easy to miss because no one had bothered to use managed transitive dependencies.
            </div><p>Gradle offers you different ways to express first-level and transitive dependencies. With Gradle you can mix and match approaches; for example, you could store your jars in an SCM
                without XML descriptor files and still use transitive dependency management.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:version_conflicts" class="section-anchor" href="#sub:version_conflicts"></a>24.2.3.&nbsp;Resolve version conflicts</h3></div></div></div><p>Conflicting versions of the same jar should be detected and either resolved or cause an exception. If you don't use transitive dependency management, version conflicts are undetected
                and the often accidental order of the classpath will determine what version of a dependency will win. On a large project with many developers changing dependencies, successful builds
                will be few and far between as the order of dependencies may directly affect whether a build succeeds or fails (or whether a bug appears or disappears in production).
            </p><p>If you haven't had to deal with the curse of conflicting versions of jars on a classpath, here is a small anecdote of the fun that awaits you. In a large project with 30
                submodules, adding a dependency to a subproject changed the order of a classpath, swapping Spring 2.5 for an older 2.4 version. While
                the build continued to work, developers were starting to notice all sorts of surprising (and surprisingly awful) bugs in production. Worse yet, this unintentional downgrade of Spring
                introduced several security vulnerabilities into the system, which now required a full security audit throughout the organization.
            </p><p>In short, version conflicts are bad, and you should manage your transitive dependencies to avoid them. You might also want to learn where conflicting versions are used and consolidate on a
                particular version of a dependency across your organization. With a good conflict reporting tool like Gradle, that information can be used to communicate with the entire organization
                and standardize on a single version.
                <span class="emphasis"><em>If you think version conflicts don't happen to you, think again.</em></span>
                It is very common for different first-level dependencies to rely on a range of different overlapping versions for other dependencies, and the JVM doesn't yet offer an easy way to have
                different versions of the same jar in the classpath (see <a class="xref" href="dependency_management.html#sub:dependency_management_and_java">Section&nbsp;24.1.2, &ldquo;Dependency management and Java&rdquo;</a>).
            </p><p>Gradle offers the following conflict resolution strategies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="emphasis"><em>Newest</em></span>: The newest version of the dependency is used. This is Gradle's default strategy, and is often an appropriate choice as long as versions are backwards-compatible.
                </li><li class="listitem"><span class="emphasis"><em>Fail</em></span>: A version conflict results in a build failure. This strategy requires all version conflicts to be resolved explicitly in the build script. See
                    <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a> for details on how to explicitly choose a particular version.
                </li></ul></div><p>While the strategies introduced above are usually enough to solve most conflicts, Gradle provides more fine-grained mechanisms to resolve version conflicts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    Configuring a first level dependency as <span class="emphasis"><em>forced</em></span>. This approach is useful if the dependency in conflict is already a first level dependency.
                    See examples in <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a>.
                </li><li class="listitem">
                    Configuring any dependency (transitive or not) as <span class="emphasis"><em>forced</em></span>. This approach is useful if the dependency in conflict is a transitive dependency.
                    It also can be used to force versions of first level dependencies.
                    See examples in <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a></li><li class="listitem">
                    Configuring dependency resolution to <span class="emphasis"><em>prefer modules that are part of your build</em></span> (transitive or not). This approach is useful if your build
                    contains custom forks of modules (as part of <a class="xref" href="multi_project_builds.html">Chapter&nbsp;25, <i>Multi-project Builds</i></a> or as include in <a class="xref" href="composite_builds.html">Chapter&nbsp;10, <i>Composite builds</i></a>). See examples in
                    <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>.
                </li><li class="listitem">
                    Dependency resolve rules are an <a class="link" href="feature_lifecycle.html">incubating</a> feature introduced in Gradle 1.4 which give you fine-grained control over the version selected for a particular dependency.
                </li></ul></div><p>To deal with problems due to version conflicts, reports with dependency graphs are also very helpful. Such reports are another feature of dependency management.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:dynamic_versions_and_changing_modules" class="section-anchor" href="#sub:dynamic_versions_and_changing_modules"></a>24.2.4.&nbsp;Use Dynamic Versions and Changing Modules</h3></div></div></div><p>There are many situations when you want to use the latest version of a particular dependency, or the latest in a range of versions. This can be a requirement during development, or
                you may be developing a library that is designed to work with a range of dependency versions. You can easily depend on these constantly changing dependencies by using a
                <span class="emphasis"><em>dynamic version</em></span>. A dynamic version can be either a version range (e.g. <code class="literal">2.+</code>) or it can be a placeholder for the latest version available
                (e.g. <code class="literal">latest.integration</code>).
            </p><p>Alternatively, sometimes the module you request can change over time, even for the same version. An example of this type of <span class="emphasis"><em>changing module</em></span>
                is a Maven <code class="literal">SNAPSHOT</code> module, which always points at the latest artifact published. In other words, a standard Maven snapshot is a module that never stands still
                so to speak, it is a &ldquo;changing module&rdquo;.
            </p><p>The main difference between a <span class="emphasis"><em>dynamic version</em></span> and a <span class="emphasis"><em>changing module</em></span> is that when you resolve a <span class="emphasis"><em>dynamic version</em></span>, you'll
                get the real, static version as the module name. When you resolve a <span class="emphasis"><em>changing module</em></span>, the artifacts are named using the version you requested, but the underlying
                artifacts may change over time.
            </p><p>By default, Gradle caches dynamic versions and changing modules for 24 hours. You can override the default cache modes using <a class="link" href="dependency_management.html#sec:cache_command_line_options">command
                line options</a>. You can change the cache expiry times in your build using the resolution strategy (see <a class="xref" href="dependency_management.html#sec:controlling_caching">Section&nbsp;24.9.3, &ldquo;Fine-tuned control over dependency caching&rdquo;</a>).
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:configurations" class="section-anchor" href="#sub:configurations"></a>24.3.&nbsp;Dependency configurations</h2></div></div></div><p>In Gradle dependencies are grouped into configurations. Configurations have a name, a number of other properties,
            and they can extend each other.
            Many Gradle plugins add pre-defined configurations to your project. The Java plugin, for example,
            adds some configurations to represent the various classpaths it needs. see
            <a class="xref" href="java_plugin.html#sec:java_plugin_and_dependency_management">Section&nbsp;46.5, &ldquo;Dependency management&rdquo;</a>
            for details. Of course you can add custom configurations on top of that. There are many use cases
            for custom configurations. This is very handy for example for adding dependencies not needed for
            building or testing your software (e.g. additional JDBC drivers to be shipped with your distribution).
        </p><p>
            A project's configurations are managed by a <code class="literal">configurations</code> object. The closure you pass to
            the configurations object is applied against its API. To learn more about this API have a look at
            <a class="ulink" href="../dsl/org.gradle.api.artifacts.ConfigurationContainer.html" target="_top"><code class="classname">ConfigurationContainer</code></a>.
        </p><p>To define a configuration:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="defineConfiguration"></a><p class="title"><b>Example&nbsp;24.1.&nbsp;Definition of a configuration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    compile
}
</pre></div></div><br class="example-break"><p>To access a configuration:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="defineConfiguration"></a><p class="title"><b>Example&nbsp;24.2.&nbsp;Accessing a configuration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">println configurations.compile.name
println configurations[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compile'</span>].name
</pre></div></div><br class="example-break"><p>To configure a configuration:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="defineConfiguration"></a><p class="title"><b>Example&nbsp;24.3.&nbsp;Configuration of a configuration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    compile {
        description = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compile classpath'</span>
        transitive = true
    }
    runtime {
        extendsFrom compile
    }
}
configurations.compile {
    description = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compile classpath'</span>
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:how_to_declare_your_dependencies" class="section-anchor" href="#sec:how_to_declare_your_dependencies"></a>24.4.&nbsp;How to declare your dependencies</h2></div></div></div><p>There are several different types of dependencies that you can declare:
        </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><p class="title"><b>Table&nbsp;24.1.&nbsp;Dependency types</b></p><div class="table-contents"><table id="N12616"><thead><tr>
                    <td>Type</td>
                    <td>Description</td>
                </tr></thead><tr>
                <td>
                    <a class="link" href="dependency_management.html#sub:module_dependencies">External module dependency</a>
                </td>
                <td>A dependency on an external module in some repository.</td>
            </tr><tr>
                <td>
                    <a class="link" href="dependency_management.html#sub:project_dependencies">Project dependency</a>
                </td>
                <td>A dependency on another project in the same build.</td>
            </tr><tr>
                <td>
                    <a class="link" href="dependency_management.html#sub:file_dependencies">File dependency</a>
                </td>
                <td>A dependency on a set of files on the local filesystem.</td>
            </tr><tr>
                <td>
                    <a class="link" href="dependency_management.html#sub:client_module_dependencies">Client module dependency</a>
                </td>
                <td>A dependency on an external module, where the artifacts are located in some repository but the module meta-data
                    is specified by the local build. You use this kind of dependency when you want to override the meta-data for the module.
                </td>
            </tr><tr>
                <td>
                    <a class="link" href="dependency_management.html#sub:api_dependencies">Gradle API dependency</a>
                </td>
                <td>A dependency on the API of the current Gradle version.
                    You use this kind of dependency when you are developing custom Gradle plugins and task types.
                </td>
            </tr><tr>
                <td>
                    <a class="link" href="dependency_management.html#sub:groovy_dependencies">Local Groovy dependency</a>
                </td>
                <td>A dependency on the Groovy version used by the current Gradle version.
                    You use this kind of dependency when you are developing custom Gradle plugins and task types.
                </td>
            </tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:module_dependencies" class="section-anchor" href="#sub:module_dependencies"></a>24.4.1.&nbsp;External module dependencies</h3></div></div></div><p>External module dependencies are the most common dependencies. They refer to a module in an external repository.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="moduleDependencies"></a><p class="title"><b>Example&nbsp;24.4.&nbsp;Module dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    runtime group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.springframework'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'spring-core'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'2.5'</span>
    runtime <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.springframework:spring-core:2.5'</span>,
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.springframework:spring-aop:2.5'</span>
    runtime(
        [group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.springframework'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'spring-core'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'2.5'</span>],
        [group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.springframework'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'spring-aop'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'2.5'</span>]
    )
    runtime(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.hibernate:hibernate:3.0.5'</span>) {
        transitive = true
    }
    runtime group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.hibernate'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hibernate'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'3.0.5'</span>, transitive: true
    runtime(group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.hibernate'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hibernate'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'3.0.5'</span>) {
        transitive = true
    }
}
</pre></div></div><br class="example-break"><p>See the <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a> class in the API documentation
                for more examples and a complete reference.
            </p><p>Gradle provides different notations for module dependencies. There is a string notation and
                a map notation. A module dependency has an API which allows further configuration. Have a look at
                <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ExternalModuleDependency.html" target="_top"><code class="classname">ExternalModuleDependency</code></a>
                to learn all about the API.
                This API provides properties and configuration methods. Via the string notation you can define a subset
                of the properties. With the map notation you can define all properties. To have access to the complete API,
                either with the map or with the string notation, you can assign a single dependency to a configuration
                together with a closure.
            </p><p>If you declare a module dependency, Gradle looks for a module descriptor file (<code class="filename">pom.xml</code> or
                <code class="filename">ivy.xml</code>) in the repositories. If such a module descriptor file exists, it is parsed and the artifacts of
                this module (e.g. <code class="filename">hibernate-3.0.5.jar</code>) as well as its dependencies (e.g. cglib) are downloaded. If no such
                module descriptor file exists, Gradle looks for a file called <code class="filename">hibernate-3.0.5.jar</code>
                to retrieve. In Maven, a module can have one and only one artifact. In Gradle and Ivy, a module can have multiple artifacts.
                Each artifact can have a different set of dependencies.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="ssub:multi_artifact_dependencies" class="section-anchor" href="#ssub:multi_artifact_dependencies"></a>Depending on modules with multiple artifacts</h4></div></div></div>
                As mentioned earlier, a Maven module has only one artifact. Hence, when your project depends on a Maven module, it's obvious what its artifact is.
                With Gradle or Ivy, the case is different. Ivy's dependency descriptor (<code class="filename">ivy.xml</code>) can declare multiple artifacts.
                For more information, see the Ivy reference for <code class="filename">ivy.xml</code>.
                In Gradle, when you declare a dependency on an Ivy module, you actually declare a dependency on the <code class="literal">default</code> configuration of that module.
                So the actual set of artifacts (typically jars) you depend on is the set of artifacts that are associated with the
                <code class="literal">default</code> configuration of that module. Here are some situations where this matters:
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">default</code> configuration of a module contains undesired artifacts. Rather than depending on the
                        whole configuration, a dependency on just the desired artifacts is declared.
                    </li><li class="listitem">The desired artifact belongs to a configuration other than <code class="literal">default</code>. That configuration is explicitly named
                        as part of the dependency declaration.
                    </li></ul></div>
                There are other situations where it is necessary to fine-tune dependency declarations.
                Please see the <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a> class in the API documentation for examples and a complete reference for declaring dependencies.
            </div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="ssub:artifact_dependencies" class="section-anchor" href="#ssub:artifact_dependencies"></a>Artifact only notation</h4></div></div></div><p>As said above, if no module descriptor file can be found, Gradle by default
                    downloads a jar with the name of the module. But sometimes, even if the repository contains module descriptors, you want to download only the artifact jar, without
                    the dependencies.
                    <sup>[<a href="#ftn.N126BE" name="N126BE" class="footnote">11</a>]</sup>
                    And sometimes you want to download a zip from a repository, that does not have module descriptors. Gradle provides an <span class="emphasis"><em>artifact only</em></span>
                    notation for those use cases - simply prefix the extension that you want to be downloaded with <code class="literal">'@'</code> sign:
                    </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="artifactOnly"></a><p class="title"><b>Example&nbsp;24.5.&nbsp;Artifact only notation</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    runtime <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.groovy:groovy:2.2.0@jar"</span>
    runtime group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.groovy'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'groovy'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'2.2.0'</span>, ext: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'jar'</span>
}
</pre></div></div><p><br class="example-break">
                    An artifact only notation creates a module dependency which downloads only the artifact file with the specified extension. Existing module descriptors are ignored.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:classifiers" class="section-anchor" href="#sub:classifiers"></a>Classifiers</h4></div></div></div><p>The Maven dependency management has the notion of classifiers.
                    <sup>[<a href="#ftn.N126DC" name="N126DC" class="footnote">12</a>]</sup>
                    Gradle supports this. To retrieve classified dependencies from a Maven repository you can write:
                </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="classifier"></a><p class="title"><b>Example&nbsp;24.6.&nbsp;Dependency with classifier</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">compile <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.gradle.test.classifiers:service:1.0:jdk15@jar"</span>
otherConf group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.gradle.test.classifiers'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'service'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.0'</span>, classifier: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'jdk14'</span>
</pre></div></div><br class="example-break"><p>As can be seen in the first line above, classifiers can be used together with the artifact only notation.
                </p></div><p>It is easy to iterate over the dependency artifacts of a configuration:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="externalDependencies"></a><p class="title"><b>Example&nbsp;24.7.&nbsp;Iterating over a configuration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task listJars {
    doLast {
        configurations.compile.each { File file -&gt; println file.name }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q listJars</code></strong></p><pre class="screen">&gt; gradle -q listJars
hibernate-core-3.6.7.Final.jar
antlr-2.7.6.jar
commons-collections-3.1.jar
dom4j-1.6.1.jar
hibernate-commons-annotations-3.2.0.Final.jar
hibernate-jpa-2.0-api-1.0.1.Final.jar
jta-1.1.jar
slf4j-api-1.6.1.jar
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:client_module_dependencies" class="section-anchor" href="#sub:client_module_dependencies"></a>24.4.2.&nbsp;Client module dependencies</h3></div></div></div><p>Client module dependencies allow you to declare <span class="emphasis"><em>transitive</em></span> dependencies directly in the build script. They are a replacement for a module descriptor
                in an external repository.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="client-modules"></a><p class="title"><b>Example&nbsp;24.8.&nbsp;Client module dependencies - transitive dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    runtime module(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.codehaus.groovy:groovy:2.4.7"</span>) {
        dependency(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"commons-cli:commons-cli:1.0"</span>) {
            transitive = false
        }
        module(group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.apache.ant'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'ant'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.9.6'</span>) {
            dependencies <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.apache.ant:ant-launcher:1.9.6@jar"</span>,
                         <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.apache.ant:ant-junit:1.9.6"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>This declares a dependency on Groovy. Groovy itself has dependencies. But Gradle does
                not look for an XML descriptor to figure them out but gets the information from the build file. The
                dependencies of a client module can be normal module dependencies or artifact dependencies or another
                client module. Also look at the API documentation for the <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ClientModule.html" target="_top"><code class="classname">ClientModule</code></a> class.
            </p><p>In the current release client modules have one limitation. Let's say your project is a library and
                you want this library to be uploaded to your company's Maven or Ivy repository. Gradle uploads the
                jars of your project to the company repository together with the XML descriptor file of the dependencies.
                If you use client modules the dependency declaration in the XML descriptor file is not correct. We will
                improve this in a future release of Gradle.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:project_dependencies" class="section-anchor" href="#sub:project_dependencies"></a>24.4.3.&nbsp;Project dependencies</h3></div></div></div><p>Gradle distinguishes between external dependencies and dependencies on projects which are part of the
                same multi-project build. For the latter you can declare <em class="firstterm">Project Dependencies</em>.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="project-dependencies"></a><p class="title"><b>Example&nbsp;24.9.&nbsp;Project dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    compile project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':shared'</span>)
}
</pre></div></div><br class="example-break"><p>For more information see the API documentation for
                <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ProjectDependency.html" target="_top"><code class="classname">ProjectDependency</code></a>.
            </p><p>Multi-project builds are discussed in <a class="xref" href="multi_project_builds.html">Chapter&nbsp;25, <i>Multi-project Builds</i></a>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:file_dependencies" class="section-anchor" href="#sub:file_dependencies"></a>24.4.4.&nbsp;File dependencies</h3></div></div></div><p>File dependencies allow you to directly add a set of files to a configuration, without first adding
                them to a repository. This can be useful if you cannot, or do not want to, place certain files in a
                repository. Or if you do not want to use any repositories at all for storing your dependencies.
            </p><p>To add some files as a dependency for a configuration, you simply pass a
                <a class="link" href="working_with_files.html#sec:file_collections">file collection</a>
                as a dependency:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="file-dependencies"></a><p class="title"><b>Example&nbsp;24.10.&nbsp;File dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    runtime files(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'libs/a.jar'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'libs/b.jar'</span>)
    runtime fileTree(dir: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'libs'</span>, include: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'*.jar'</span>)
}
</pre></div></div><br class="example-break"><p>File dependencies are not included in the published dependency descriptor for your project.
                However, file dependencies are included in transitive project dependencies within the same build.
                This means they cannot be used outside the current build, but they can be used with the same build.
            </p><p>
                You can declare which tasks produce the files for a file dependency. You might do this when, for example,
                the files are generated by the build.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="generatedFileDependencies"></a><p class="title"><b>Example&nbsp;24.11.&nbsp;Generated file dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    compile files(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$buildDir/classes"</span>) {
        builtBy <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compile'</span>
    }
}

task compile {
    doLast {
        println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compiling classes'</span>
    }
}

task list(dependsOn: configurations.compile) {
    doLast {
        println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"classpath = ${configurations.compile.collect { File file -&gt; file.name }}"</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q list</code></strong></p><pre class="screen">&gt; gradle -q list
compiling classes
classpath = [classes]
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:api_dependencies" class="section-anchor" href="#sub:api_dependencies"></a>24.4.5.&nbsp;Gradle API Dependency</h3></div></div></div><p>You can declare a dependency on the API of the current version of Gradle by using the <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleApi()" target="_top"><code class="classname">DependencyHandler.gradleApi()</code></a>
                method. This is useful when you are developing custom Gradle tasks or plugins.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="gradle-api-dependencies"></a><p class="title"><b>Example&nbsp;24.12.&nbsp;Gradle API dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    compile gradleApi()
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:groovy_dependencies" class="section-anchor" href="#sub:groovy_dependencies"></a>24.4.6.&nbsp;Local Groovy Dependency</h3></div></div></div><p>You can declare a dependency on the Groovy that is distributed with Gradle by using the <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:localGroovy()" target="_top"><code class="classname">DependencyHandler.localGroovy()</code></a>
                method. This is useful when you are developing custom Gradle tasks or plugins in Groovy.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="local-groovy-dependencies"></a><p class="title"><b>Example&nbsp;24.13.&nbsp;Gradle's Groovy dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    compile localGroovy()
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:exclude_transitive_dependencies" class="section-anchor" href="#sub:exclude_transitive_dependencies"></a>24.4.7.&nbsp;Excluding transitive dependencies</h3></div></div></div><p>You can exclude a <span class="emphasis"><em>transitive</em></span> dependency either by configuration or by dependency:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="exclude-dependencies"></a><p class="title"><b>Example&nbsp;24.14.&nbsp;Excluding transitive dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    compile.exclude module: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'commons'</span>
    all*.exclude group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.gradle.test.excludes'</span>, module: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'reports'</span>
}

dependencies {
    compile(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.gradle.test.excludes:api:1.0"</span>) {
        exclude module: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'shared'</span>
    }
}
</pre></div></div><br class="example-break"><p>If you define an exclude for a particular configuration, the excluded transitive dependency will be filtered for all
                dependencies when resolving this configuration or any inheriting configuration.
                If you want to exclude a transitive dependency from all your
                configurations you can use the Groovy spread-dot operator to express this in a concise way, as shown in the example.
                When defining an exclude, you can specify either only the organization or only the module name or both.
                Also look at the API documentation of the <a class="ulink" href="../javadoc/org/gradle/api/artifacts/Dependency.html" target="_top"><code class="classname">Dependency</code></a> and <a class="ulink" href="../dsl/org.gradle.api.artifacts.Configuration.html" target="_top"><code class="classname">Configuration</code></a> classes.
            </p><p>
                Not every transitive dependency can be excluded - some transitive dependencies might be essential
                for correct runtime behavior of the application. Generally, one can exclude transitive
                dependencies that are either not required by runtime or that are guaranteed to be available
                on the target environment/platform.
            </p><p>
                Should you exclude per-dependency or per-configuration?
                It turns out that in the majority of cases you want to use the per-configuration exclusion.
                Here are some typical reasons why one might want to exclude a transitive dependency.
                Bear in mind that for some of these use cases there are better solutions than exclusions!
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The dependency is undesired due to licensing reasons.</li><li class="listitem">The dependency is not available in any remote repositories.</li><li class="listitem">The dependency is not needed for runtime.</li><li class="listitem">The dependency has a version that conflicts with a desired version. For that use case please refer to <a class="xref" href="dependency_management.html#sub:version_conflicts">Section&nbsp;24.2.3, &ldquo;Resolve version conflicts&rdquo;</a>
                        and the documentation on <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a> for a potentially better solution to the problem.
                    </li></ul></div><p>
                Basically, in most of the cases excluding the transitive dependency should be done per configuration.
                This way the dependency declaration is more explicit. It is also more accurate because a per-dependency
                exclude rule does not guarantee the given transitive dependency does not show up in the configuration.
                For example, some other dependency, which does not have any exclude rules, might pull in
                that unwanted transitive dependency.
            </p><p>
                Other examples of dependency exclusions can be found in the reference for the <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ModuleDependency.html" target="_top"><code class="classname">ModuleDependency</code></a> or
                <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a> classes.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:optional_attributes" class="section-anchor" href="#sec:optional_attributes"></a>24.4.8.&nbsp;Optional attributes</h3></div></div></div><p><a xmlns:xslthl="http://xslthl.sf.net" name="para:dependencies_with_empty_attributes"></a>All attributes for a dependency are optional, except the name.
                Which attributes are required for actually finding dependencies in the repository will depend on the repository type.
                See <a class="xref" href="dependency_management.html#sec:repositories">Section&nbsp;24.6, &ldquo;Repositories&rdquo;</a>. For example, if you work with Maven repositories, you need to define the
                group, name and version. If you work with filesystem repositories you might only need the name or the name
                and the version.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="dependenciesWithEmptyAttributes"></a><p class="title"><b>Example&nbsp;24.15.&nbsp;Optional attributes of dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    runtime <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":junit:4.12"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":testng"</span>
    runtime name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'testng'</span>
}
</pre></div></div><br class="example-break"><p><a xmlns:xslthl="http://xslthl.sf.net" name="para:notation_collections"></a>You can also assign collections or arrays of dependency notations to a configuration:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="listGrouping"></a><p class="title"><b>Example&nbsp;24.16.&nbsp;Collections and arrays of dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">List groovy = [<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.codehaus.groovy:groovy-all:2.4.7@jar"</span>,
               <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"commons-cli:commons-cli:1.0@jar"</span>,
               <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.apache.ant:ant:1.9.6@jar"</span>]
List hibernate = [<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.hibernate:hibernate:3.0.5@jar'</span>,
                  <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'somegroup:someorg:1.0@jar'</span>]
dependencies {
    runtime groovy, hibernate
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:dependency_configurations" class="section-anchor" href="#sec:dependency_configurations"></a>24.4.9.&nbsp;Dependency configurations</h3></div></div></div><p>In Gradle a dependency can have different configurations (as your project can have different configurations). If you
                don't specify anything explicitly, Gradle uses the default configuration of the dependency. For dependencies
                from a Maven repository, the default configuration is the only possibility anyway. If you work with Ivy repositories and
                want to declare a non-default configuration for your dependency you have to use the map notation and declare:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="dependencyConfigurations"></a><p class="title"><b>Example&nbsp;24.17.&nbsp;Dependency configurations</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    runtime group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.somegroup'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'somedependency'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.0'</span>, configuration: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'someConfiguration'</span>
}
</pre></div></div><br class="example-break"><p>To do the same for project dependencies you need to declare:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="dependencyConfigurationsProjects"></a><p class="title"><b>Example&nbsp;24.18.&nbsp;Dependency configurations for project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    compile project(path: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':api'</span>, configuration: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'spi'</span>)
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:dependency_reports" class="section-anchor" href="#sec:dependency_reports"></a>24.4.10.&nbsp;Dependency reports</h3></div></div></div><p>You can generate dependency reports from the command line (see <a class="xref" href="tutorial_gradle_command_line.html#para:commandline_dependency_report">Section&nbsp;4.7.4, &ldquo;Listing project dependencies&rdquo;</a>).
                With the help of the Project report plugin (see <a class="xref" href="project_reports_plugin.html">Chapter&nbsp;28, <i>The Project Report Plugin</i></a>) such a report can be created by your build.
            </p><p>
                Since Gradle 1.2 there is also a new programmatic API to access the resolved dependency information.
                The dependency reports (see the previous paragraph) are using this API under the covers.
                The API lets you walk the resolved dependency graph and provides information about the dependencies.
                In future releases the API will grow to provide more information about the resolution result.
                For more information about the API please refer to the Javadocs on
                <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ResolvableDependencies.html#getResolutionResult()" target="_top"><code class="classname">ResolvableDependencies.getResolutionResult()</code></a>.
                Potential usages of the <a class="ulink" href="../javadoc/org/gradle/api/artifacts/result/ResolutionResult.html" target="_top"><code class="classname">ResolutionResult</code></a> API:
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creation of advanced dependency reports tailored to your use case.</li><li class="listitem">Enabling the build logic to make decisions based on the content of the dependency graph.</li></ul></div><p>
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:working_with_dependencies" class="section-anchor" href="#sec:working_with_dependencies"></a>24.5.&nbsp;Working with dependencies</h2></div></div></div><p>For the examples below we have the following dependencies setup:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="configurationHandlingSetup"></a><p class="title"><b>Example&nbsp;24.19.&nbsp;Configuration.copy</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    sealife
    alllife
}

dependencies {
    sealife <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sea.mammals:orca:1.0"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sea.fish:shark:1.0"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sea.fish:tuna:1.0"</span>
    alllife configurations.sealife
    alllife <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"air.birds:albatross:1.0"</span>
}
</pre></div></div><br class="example-break"><p>The dependencies have the following transitive dependencies:</p><p>shark-1.0 -&gt; seal-2.0, tuna-1.0</p><p>orca-1.0 -&gt; seal-1.0</p><p>tuna-1.0 -&gt; herring-1.0</p><p>You can use the configuration to access the declared dependencies or a subset of those:
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="configurationHandlingDependencies"></a><p class="title"><b>Example&nbsp;24.20.&nbsp;Accessing declared dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task dependencies {
    doLast {
        configurations.alllife.dependencies.each { dep -&gt; println dep.name }
        println()
        configurations.alllife.allDependencies.each { dep -&gt; println dep.name }
        println()
        configurations.alllife.allDependencies.findAll { dep -&gt; dep.name != <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'orca'</span> }
            .each { dep -&gt; println dep.name }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q dependencies</code></strong></p><pre class="screen">&gt; gradle -q dependencies
albatross

albatross
orca
shark
tuna

albatross
shark
tuna
</pre></div></div><br class="example-break"><p>The <code class="code">dependencies</code> task returns only the dependencies belonging explicitly to the configuration.
            The <code class="code">allDependencies</code> task includes the dependencies from extended configurations.
        </p><p>To get the library files of the configuration dependencies you can do:
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="configurationHandlingAllFiles"></a><p class="title"><b>Example&nbsp;24.21.&nbsp;Configuration.files</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task allFiles {
    doLast {
        configurations.sealife.files.each { file -&gt;
            println file.name
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q allFiles</code></strong></p><pre class="screen">&gt; gradle -q allFiles
orca-1.0.jar
shark-1.0.jar
tuna-1.0.jar
herring-1.0.jar
seal-2.0.jar</pre></div></div><br class="example-break"><p>Sometimes you want the library files of a subset of the configuration dependencies (e.g. of a single dependency).
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="configurationHandlingFiles"></a><p class="title"><b>Example&nbsp;24.22.&nbsp;Configuration.files with spec</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task files {
    doLast {
        configurations.sealife.files { dep -&gt; dep.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'orca'</span> }.each { file -&gt;
            println file.name
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q files</code></strong></p><pre class="screen">&gt; gradle -q files
orca-1.0.jar
seal-2.0.jar</pre></div></div><br class="example-break"><p>The <code class="code">Configuration.files</code> method always retrieves all artifacts of the <span class="emphasis"><em>whole</em></span>
            configuration. It then filters the retrieved files by specified dependencies. As you can see in the example, transitive dependencies are included.
        </p><p>You can also copy a configuration. You can optionally specify that only a subset of dependencies from the original configuration
            should be copied. The copying methods come in two flavors. The <code class="code">copy</code> method copies only the dependencies belonging explicitly to the configuration. The
            <code class="code">copyRecursive</code> method copies all the dependencies, including the dependencies from extended configurations.
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="configurationHandlingCopy"></a><p class="title"><b>Example&nbsp;24.23.&nbsp;Configuration.copy</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copy {
    doLast {
        configurations.alllife.copyRecursive { dep -&gt; dep.name != <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'orca'</span> }
            .allDependencies.each { dep -&gt; println dep.name }
        println()
        configurations.alllife.copy().allDependencies
            .each { dep -&gt; println dep.name }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q copy</code></strong></p><pre class="screen">&gt; gradle -q copy
albatross
shark
tuna

albatross
</pre></div></div><br class="example-break"><p>It is important to note that the returned files of the copied configuration
            are often but not always the same than the returned files of the dependency subset of the original configuration.
            In case of version conflicts between dependencies of the subset and dependencies not belonging to the subset the resolve result might be different.
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="configurationHandlingCopyVsFiles"></a><p class="title"><b>Example&nbsp;24.24.&nbsp;Configuration.copy vs. Configuration.files</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copyVsFiles {
    doLast {
        configurations.sealife.copyRecursive { dep -&gt; dep.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'orca'</span> }
            .each { file -&gt; println file.name }
        println()
        configurations.sealife.files { dep -&gt; dep.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'orca'</span> }
            .each { file -&gt; println file.name }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q copyVsFiles</code></strong></p><pre class="screen">&gt; gradle -q copyVsFiles
orca-1.0.jar
seal-1.0.jar

orca-1.0.jar
seal-2.0.jar</pre></div></div><br class="example-break"><p>In the example above, <code class="code">orca</code> has a dependency on <code class="code">seal-1.0</code> whereas <code class="code">shark</code> has a dependency on<code class="code">seal-2.0</code>. The original configuration
            has therefore a version conflict which is resolved to the newer <code class="code">seal-2.0</code> version. The <code class="code">files</code> method therefore returns <code class="code">seal-2.0</code> as a
            transitive dependency of<code class="code">orca</code>. The copied configuration only has <code class="code">orca</code> as a dependency and therefore there is no version conflict and <code class="code">seal-1.0</code>
            is returned as a transitive dependency.
        </p><p>Once a configuration is resolved it is immutable. Changing its state or the state of one of its dependencies
            will cause an exception. You can always copy a resolved configuration. The copied configuration is in the unresolved
            state and can be freshly resolved.
        </p><p>To learn more about the API of the configuration class see the API documentation:
            <a class="ulink" href="../dsl/org.gradle.api.artifacts.Configuration.html" target="_top"><code class="classname">Configuration</code></a>.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:repositories" class="section-anchor" href="#sec:repositories"></a>24.6.&nbsp;Repositories</h2></div></div></div><p>Gradle repository management, based on Apache Ivy, gives you a lot of freedom regarding repository layout and retrieval policies.
            Additionally Gradle provides various convenience method to add pre-configured repositories.
        </p><p>You may configure any number of repositories, each of which is treated independently by Gradle. If Gradle finds a module descriptor in a
            particular repository, it will attempt to download all of the artifacts for that module from <span class="emphasis"><em>the same repository</em></span>.
            Although module meta-data and module artifacts must be located in the same repository, it is possible to compose a single repository of multiple
            URLs, giving multiple locations to search for meta-data files and jar files.
        </p><p>There are several different types of repositories you can declare:</p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><p class="title"><b>Table&nbsp;24.2.&nbsp;Repository types</b></p><div class="table-contents"><table id="N128EA"><thead><tr>
                    <td>Type</td>
                    <td>Description</td>
                </tr></thead><tr>
                <td>
                    <a class="link" href="dependency_management.html#sub:maven_central">Maven central repository</a>
                </td>
                <td>A pre-configured repository that looks for dependencies in Maven Central.</td>
            </tr><tr>
                <td>
                    <a class="link" href="dependency_management.html#sub:maven_jcenter">Maven JCenter repository</a>
                </td>
                <td>A pre-configured repository that looks for dependencies in Bintray's JCenter.</td>
            </tr><tr>
                <td>
                    <a class="link" href="dependency_management.html#sub:maven_local">Maven local repository</a>
                </td>
                <td>A pre-configured repository that looks for dependencies in the local Maven repository.</td>
            </tr><tr>
                <td>
                    <a class="link" href="dependency_management.html#sub:maven_repo">Maven repository</a>
                </td>
                <td>A Maven repository. Can be located on the local filesystem or at some remote location.</td>
            </tr><tr>
                <td>
                    <a class="link" href="dependency_management.html#sec:ivy_repositories">Ivy repository</a>
                </td>
                <td>An Ivy repository. Can be located on the local filesystem or at some remote location.</td>
            </tr><tr>
                <td>
                    <a class="link" href="dependency_management.html#sec:flat_dir_resolver">Flat directory repository</a>
                </td>
                <td>A simple repository on the local filesystem. Does not support any meta-data formats.</td>
            </tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:maven_central" class="section-anchor" href="#sub:maven_central"></a>24.6.1.&nbsp;Maven central repository</h3></div></div></div><p>To add the central Maven 2 repository (<a class="ulink" href="http://repo1.maven.org/maven2" target="_top">http://repo1.maven.org/maven2</a>) simply add this to your build script:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="mavenCentral"></a><p class="title"><b>Example&nbsp;24.25.&nbsp;Adding central Maven repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    mavenCentral()
}
</pre></div></div><br class="example-break"><p>Now Gradle will look for your dependencies in this repository.</p><p>
                <span class="emphasis"><em>Warning:</em></span> Be aware that the central Maven 2 repository is HTTP only and
                HTTPS is not supported. If you need a public HTTPS enabled central repository, you can use the <a class="ulink" href="http://jcenter.bintray.com" target="_top">JCenter</a> public repository (see <a class="xref" href="dependency_management.html#sub:maven_jcenter">Section&nbsp;24.6.2, &ldquo;Maven JCenter repository&rdquo;</a>).
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:maven_jcenter" class="section-anchor" href="#sub:maven_jcenter"></a>24.6.2.&nbsp;Maven JCenter repository</h3></div></div></div><p><a class="ulink" href="http://bintray.com" target="_top">Bintray</a>'s JCenter is an up-to-date collection of all popular Maven OSS artifacts, including artifacts published directly to Bintray.
            </p><p>To add the JCenter Maven repository (<a class="ulink" href="https://jcenter.bintray.com" target="_top">https://jcenter.bintray.com</a>) simply add this to your build script:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="mavenJcenter"></a><p class="title"><b>Example&nbsp;24.26.&nbsp;Adding Bintray's JCenter Maven repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    jcenter()
}
</pre></div></div><br class="example-break"><p>Now Gradle will look for your dependencies in the JCenter repository. <span class="emphasis"><em>jcenter()</em></span> uses HTTPS to connect to the repository.
                If you want to use HTTP you can configure <code class="literal">jcenter()</code>:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="mavenJcenter"></a><p class="title"><b>Example&nbsp;24.27.&nbsp;Using Bintrays's JCenter with HTTP</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    jcenter {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://jcenter.bintray.com/"</span>
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:maven_local" class="section-anchor" href="#sub:maven_local"></a>24.6.3.&nbsp;Local Maven repository</h3></div></div></div><p>To use the local Maven cache as a repository you can do:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="mavenLocalRepo"></a><p class="title"><b>Example&nbsp;24.28.&nbsp;Adding the local Maven cache as a repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    mavenLocal()
}
</pre></div></div><br class="example-break"><p>Gradle uses the same logic as Maven to identify the location of your local Maven cache. If a local repository location is defined in a <code class="filename">settings.xml</code>, this location
                will be used. The <code class="filename">settings.xml</code> in <code class="filename"><em class="replaceable"><code>USER_HOME</code></em>/.m2</code> takes precedence over the <code class="filename">settings.xml</code>
                in <code class="filename"><em class="replaceable"><code>M2_HOME</code></em>/conf</code>. If no <code class="filename">settings.xml</code> is available, Gradle uses the default location
                <code class="filename"><em class="replaceable"><code>USER_HOME</code></em>/.m2/repository</code>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:maven_repo" class="section-anchor" href="#sub:maven_repo"></a>24.6.4.&nbsp;Maven repositories</h3></div></div></div><p>For adding a custom Maven repository you can do:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="mavenLikeRepo"></a><p class="title"><b>Example&nbsp;24.29.&nbsp;Adding custom Maven repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/maven2"</span>
    }
}
</pre></div></div><br class="example-break"><p>Sometimes a repository will have the POMs published to one location, and the JARs and other artifacts published at another location.
                To define such a repository, you can do:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="mavenLikeRepoWithJarRepo"></a><p class="title"><b>Example&nbsp;24.30.&nbsp;Adding additional Maven repositories for JAR files</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Look for POMs and artifacts, such as JARs, here</span>
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo2.mycompany.com/maven2"</span>
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Look for artifacts here if not found at the above location</span>
        artifactUrls <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/jars"</span>
        artifactUrls <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/jars2"</span>
    }
}
</pre></div></div><br class="example-break"><p>Gradle will look at the first URL for the POM and the JAR. If the JAR can't be found there, the artifact URLs are used to look for JARs.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:accessing_password_protected_maven_repositories" class="section-anchor" href="#sec:accessing_password_protected_maven_repositories"></a>Accessing password protected Maven repositories</h4></div></div></div><p>To access a Maven repository which uses basic authentication, you specify the username and password to use when you define the repository:
                </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="mavenPasswordProtectedRepo"></a><p class="title"><b>Example&nbsp;24.31.&nbsp;Accessing password protected Maven repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        credentials {
            username <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'user'</span>
            password <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'password'</span>
        }
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/maven2"</span>
    }
}
</pre></div></div><br class="example-break"><p>It is advisable to keep your username and password in <code class="filename">gradle.properties</code> rather than directly in the build file.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:flat_dir_resolver" class="section-anchor" href="#sec:flat_dir_resolver"></a>24.6.5.&nbsp;Flat directory repository</h3></div></div></div><p>If you want to use a (flat) filesystem directory as a repository, simply type:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="flatDirMulti"></a><p class="title"><b>Example&nbsp;24.32.&nbsp;Flat repository resolver</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    flatDir {
        dirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib'</span>
    }
    flatDir {
        dirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib1'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib2'</span>
    }
}
</pre></div></div><br class="example-break"><p>This adds repositories which look into one or more directories for finding dependencies. Note that
                this type of repository does not support any meta-data formats like Ivy XML or Maven POM files. Instead,
                Gradle will dynamically generate a module descriptor (without any dependency information) based on the
                presence of artifacts. However, as Gradle prefers to use modules whose descriptor has been created from
                real meta-data rather than being generated, flat directory repositories cannot be used to override
                artifacts with real meta-data from other repositories. So, for example, if Gradle finds only
                <code class="filename">jmxri-1.2.1.jar</code> in a flat directory repository, but <code class="filename">jmxri-1.2.1.pom</code>
                in another repository that supports meta-data, it will use the second repository to provide the module.
                For the use case of overriding remote artifacts with local ones consider using an Ivy or Maven repository
                instead whose URL points to a local directory.
                If you only work with flat directory repositories you don't need to set all attributes of a dependency.
                See <a class="xref" href="dependency_management.html#para:dependencies_with_empty_attributes">Section&nbsp;24.4.8, &ldquo;Optional attributes&rdquo;</a>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:ivy_repositories" class="section-anchor" href="#sec:ivy_repositories"></a>24.6.6.&nbsp;Ivy repositories</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:defining_an_ivy_repository_with_a_standard_layout" class="section-anchor" href="#sec:defining_an_ivy_repository_with_a_standard_layout"></a>Defining an Ivy repository with a standard layout</h4></div></div></div><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="ivyRepository"></a><p class="title"><b>Example&nbsp;24.33.&nbsp;Ivy repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:defining_a_named_layout_for_an_ivy_repository" class="section-anchor" href="#sec:defining_a_named_layout_for_an_ivy_repository"></a>Defining a named layout for an Ivy repository</h4></div></div></div><p>
                    You can specify that your repository conforms to the Ivy or Maven default layout by using a named layout.
                </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="ivyRepository"></a><p class="title"><b>Example&nbsp;24.34.&nbsp;Ivy repository with named layout</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"maven"</span>
    }
}
</pre></div></div><br class="example-break"><p>
                    Valid named layout values are <code class="literal">'gradle'</code> (the default), <code class="literal">'maven'</code>, <code class="literal">'ivy'</code> and <code class="literal">'pattern'</code>.
                    See <a class="ulink" href="../dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html#org.gradle.api.artifacts.repositories.IvyArtifactRepository:layout(java.lang.String, groovy.lang.Closure)" target="_top"><code class="classname">IvyArtifactRepository.layout(java.lang.String, groovy.lang.Closure)</code></a> in the API documentation for details of these named layouts.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:defining_custom_pattern_layout_for_an_ivy_repository" class="section-anchor" href="#sec:defining_custom_pattern_layout_for_an_ivy_repository"></a>Defining custom pattern layout for an Ivy repository</h4></div></div></div><p>To define an Ivy repository with a non-standard layout, you can define a 'pattern' layout for the repository:
                </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="ivyRepository"></a><p class="title"><b>Example&nbsp;24.35.&nbsp;Ivy repository with pattern layout</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"pattern"</span>, {
            artifact <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"[module]/[revision]/[type]/[artifact].[ext]"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>To define an Ivy repository which fetches Ivy files and artifacts from different locations,
                    you can define separate patterns to use to locate the Ivy files and artifacts:
                </p><p>
                    Each <code class="literal">artifact</code> or <code class="literal">ivy</code> specified for a repository adds an <span class="emphasis"><em>additional</em></span> pattern to use.
                    The patterns are used in the order that they are defined.
                </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="ivyRepository"></a><p class="title"><b>Example&nbsp;24.36.&nbsp;Ivy repository with multiple custom patterns</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"pattern"</span>, {
            artifact <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"3rd-party-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"</span>
            artifact <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"company-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"</span>
            ivy <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"ivy-files/[organisation]/[module]/[revision]/ivy.xml"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>Optionally, a repository with pattern layout can have its 'organisation' part laid out in Maven style, with
                    forward slashes replacing dots as separators. For example, the organisation <code class="literal">my.company</code> would then be represented as <code class="literal">my/company</code>.
                </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="ivyRepository"></a><p class="title"><b>Example&nbsp;24.37.&nbsp;Ivy repository with Maven compatible layout</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"pattern"</span>, {
            artifact <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"</span>
            m2compatible = true
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:accessing_password_protected_ivy_repositories" class="section-anchor" href="#sec:accessing_password_protected_ivy_repositories"></a>Accessing password protected Ivy repositories</h4></div></div></div><p>To access an Ivy repository which uses basic authentication, you specify the username and password to use when you define the repository:
                </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="ivyRepository"></a><p class="title"><b>Example&nbsp;24.38.&nbsp;Ivy repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'http://repo.mycompany.com'</span>
        credentials {
            username <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'user'</span>
            password <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'password'</span>
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:supported_transport_protocols" class="section-anchor" href="#sub:supported_transport_protocols"></a>24.6.7.&nbsp;Supported repository transport protocols</h3></div></div></div><p>Maven and Ivy repositories support the use of various transport protocols. At the moment the following protocols are supported:
            </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><p class="title"><b>Table&nbsp;24.3.&nbsp;Repository transport protocols</b></p><div class="table-contents"><table id="N12A88"><thead><tr>
                        <td>Type</td>
                        <td>Credential types</td>
                    </tr></thead><tr>
                    <td><code class="literal">file</code></td>
                    <td>none</td>
                </tr><tr>
                    <td><code class="literal">http</code></td>
                    <td>username/password</td>
                </tr><tr>
                    <td><code class="literal">https</code></td>
                    <td>username/password</td>
                </tr><tr>
                    <td><code class="literal">sftp</code></td>
                    <td>username/password</td>
                </tr><tr>
                    <td><code class="literal">s3</code></td>
                    <td>access key/secret key</td>
                </tr></table></div></div><p>To define a repository use the <code class="literal">repositories</code> configuration block. Within the <code class="literal">repositories</code> closure,
                a Maven repository is declared with <code class="literal">maven</code>. An Ivy repository is declared with <code class="literal">ivy</code>. The transport protocol
                is part of the URL definition for a repository. The following build script demonstrates how to create a HTTP-based Maven and Ivy repository:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="mavenIvyRepositoriesNoAuth"></a><p class="title"><b>Example&nbsp;24.39.&nbsp;Declaring a Maven and Ivy repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/maven2"</span>
    }

    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
    }
}
</pre></div></div><br class="example-break"><p>If authentication is required for a repository, the relevant credentials can be provided. The following example shows how to provide
                username/password-based authentication for SFTP repositories:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="mavenIvyRepositoriesAuth"></a><p class="title"><b>Example&nbsp;24.40.&nbsp;Providing credentials to a Maven and Ivy repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sftp://repo.mycompany.com:22/maven2"</span>
        credentials {
            username <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'user'</span>
            password <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'password'</span>
        }
    }

    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sftp://repo.mycompany.com:22/repo"</span>
        credentials {
            username <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'user'</span>
            password <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'password'</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>When using an AWS S3 backed repository you need to authenticate using <a class="ulink" href="../dsl/org.gradle.api.credentials.AwsCredentials.html" target="_top"><code class="classname">AwsCredentials</code></a>, providing access-key and a private-key.
                The following example shows how to declare a S3 backed repository and providing AWS credentials:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="mavenIvyS3RepositoriesAuth"></a><p class="title"><b>Example&nbsp;24.41.&nbsp;Declaring a S3 backed Maven and Ivy repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"s3://myCompanyBucket/maven2"</span>
        credentials(AwsCredentials) {
            accessKey <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"someKey"</span>
            secretKey <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"someSecret"</span>
        }
    }

    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"s3://myCompanyBucket/ivyrepo"</span>
        credentials(AwsCredentials) {
            accessKey <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"someKey"</span>
            secretKey <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"someSecret"</span>
        }
    }
}
</pre></div></div><br class="example-break"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:s3_configuration properties" class="section-anchor" href="#sub:s3_configuration properties"></a>S3 configuration properties</h4></div></div></div><p>
                    The following system properties can be used to configure the interactions with s3 repositories:
                </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><p class="title"><b>Table&nbsp;24.4.&nbsp;S3 Configuration Properties</b></p><div class="table-contents"><table id="N12AFC"><thead><tr>
                            <td>Property</td>
                            <td>Description</td>
                        </tr></thead><tbody><tr>
                            <td>org.gradle.s3.endpoint</td>
                            <td>Used to override the AWS S3 endpoint when using a non AWS, S3 API compatible, storage service.</td>
                        </tr><tr>
                            <td>org.gradle.s3.maxErrorRetry</td>
                            <td>Specifies the maximum number of times to retry a request in the event that the S3 server responds with a HTTP 5xx status code. When not specified a default value of 3
                                is used.
                            </td>
                        </tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:s3_url_formats" class="section-anchor" href="#sub:s3_url_formats"></a>S3 URL formats</h4></div></div></div><p>S3 URL's are 'virtual-hosted-style' and must be in the following format
                    <code class="literal">s3://&lt;bucketName&gt;[.&lt;regionSpecificEndpoint&gt;]/&lt;s3Key&gt;</code>
                </p><p>e.g.
                    <code class="literal">s3://myBucket.s3.eu-central-1.amazonaws.com/maven/release</code>
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">myBucket</code>
                        is the AWS S3 bucket name.
                    </li><li class="listitem"><code class="literal">s3.eu-central-1.amazonaws.com</code>
                        is the <span class="emphasis"><em>optional</em></span><a class="ulink" href="http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region" target="_top"> region specific endpoint</a>.
                    </li><li class="listitem"><code class="literal">/maven/release</code>
                        is the AWS S3 key (unique identifier for an object within a bucket)
                    </li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:s3_proxy_settings" class="section-anchor" href="#sub:s3_proxy_settings"></a>S3 proxy settings</h4></div></div></div><p>A proxy for S3 can be configured using the following system properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">https.proxyHost</code></li><li class="listitem"><code class="literal">https.proxyPort</code></li><li class="listitem"><code class="literal">https.proxyUser</code></li><li class="listitem"><code class="literal">https.proxyPassword</code></li><li class="listitem"><code class="literal">http.nonProxyHosts</code></li></ul></div><p>If the 'org.gradle.s3.endpoint' property has been specified with a http (not https) URI the following system proxy settings can be used:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">http.proxyHost</code></li><li class="listitem"><code class="literal">http.proxyPort</code></li><li class="listitem"><code class="literal">http.proxyUser</code></li><li class="listitem"><code class="literal">http.proxyPassword</code></li><li class="listitem"><code class="literal">http.nonProxyHosts</code></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="s3_v4_signatures" class="section-anchor" href="#s3_v4_signatures"></a>AWS S3 V4 Signatures (AWS4-HMAC-SHA256)</h4></div></div></div><p>
                    Some of the AWS S3 regions (eu-central-1 - Frankfurt) require that all HTTP requests are signed in accordance with AWS's
                    <a class="ulink" href="http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html" target="_top">signature version 4</a>. It is recommended to specify
                    S3 URL's containing the region specific endpoint when using buckets that require V4 signatures.
                    e.g. <code class="literal">s3://somebucket.s3.eu-central-1.amazonaws.com/maven/release</code>
                </p><div class="note"><span class="emphasis"><em>NOTE:</em></span> When a region-specific endpoint is not specified for buckets requiring V4 Signatures, Gradle will use the default AWS region (us-east-1) and the
                    following warning will appear on the console:
                    <p>
                        Attempting to re-send the request to .... with AWS V4 authentication. To avoid this warning in the future, please use region-specific endpoint to access buckets located in
                        regions that require V4 signing.
                    </p><p>
                        Failing to specify the region-specific endpoint for buckets requiring V4 signatures means:
                    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">3 round-trips to AWS, as opposed to one, for every file upload and download.</code></li><li class="listitem"><code class="literal">Depending on location - increased network latencies and slower builds.</code></li><li class="listitem"><code class="literal">Increased likelihood of transmission failures.</code></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:authentication_schemes" class="section-anchor" href="#sub:authentication_schemes"></a>Configuring HTTP authentication schemes</h4></div></div></div><p>
                    When configuring a repository using HTTP or HTTPS transport protocols, multiple authentication schemes are available. By default, Gradle will attempt to use all schemes that
                    are supported by the Apache HttpClient library, <a class="ulink" href="http://hc.apache.org/httpcomponents-client-ga/tutorial/html/authentication.html#d5e625" target="_top">documented here</a>.
                    In some cases, it may be preferable to explicitly specify which authentication schemes should be used when exchanging credentials with a remote server. When explicitly
                    declared, only those schemes are used when authenticating to a remote repository. The following example show how to configure a repository to use only digest authentication:
                </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="digestAuthentication"></a><p class="title"><b>Example&nbsp;24.42.&nbsp;Configure repository to use only digest authentication</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'https://repo.mycompany.com/maven2'</span>
        credentials {
            username <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'user'</span>
            password <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'password'</span>
        }
        authentication {
            digest(DigestAuthentication)
        }
    }
}
</pre></div></div><br class="example-break"><p>
                    Currently supported authentication schemes are:
                </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><p class="title"><b>Table&nbsp;24.5.&nbsp;Authentication schemes</b></p><div class="table-contents"><table id="N12B97"><thead><tr>
                            <th>Type</th>
                            <th>Description</th>
                        </tr></thead><tbody><tr>
                            <td><a class="ulink" href="../dsl/org.gradle.authentication.http.BasicAuthentication.html" target="_top"><code class="classname">BasicAuthentication</code></a></td>
                            <td>Basic access authentication over HTTP. When using this scheme, credentials are sent preemptively.</td>
                        </tr><tr>
                            <td><a class="ulink" href="../dsl/org.gradle.authentication.http.DigestAuthentication.html" target="_top"><code class="classname">DigestAuthentication</code></a></td>
                            <td>Digest access authentication over HTTP.</td>
                        </tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:preemptive_authentication" class="section-anchor" href="#sub:preemptive_authentication"></a>Using preemptive authentication</h4></div></div></div><p>
                    Gradle's default behavior is to only submit credentials when a server responds with an authentication challenge in the form of a HTTP 401 response. In some cases,
                    the server will respond with a different code (ex. for repositories hosted on GitHub a 404 is returned) causing dependency resolution to fail. To get around this
                    behavior, credentials may be sent to the server preemptively. To enable preemptive authentication simply configure your repository to explicitly use the
                    <a class="ulink" href="../dsl/org.gradle.authentication.http.BasicAuthentication.html" target="_top"><code class="classname">BasicAuthentication</code></a> scheme:
                </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="preemptiveAuthentication"></a><p class="title"><b>Example&nbsp;24.43.&nbsp;Configure repository to use preemptive authentication</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'https://repo.mycompany.com/maven2'</span>
        credentials {
            username <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'user'</span>
            password <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'password'</span>
        }
        authentication {
            basic(BasicAuthentication)
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:working_with_repositories" class="section-anchor" href="#sec:working_with_repositories"></a>24.6.8.&nbsp;Working with repositories</h3></div></div></div><p>To access a repository:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="defineRepository"></a><p class="title"><b>Example&nbsp;24.44.&nbsp;Accessing a repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">println repositories.localRepository.name
println repositories[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'localRepository'</span>].name
</pre></div></div><br class="example-break"><p>To configure a repository:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="defineRepository"></a><p class="title"><b>Example&nbsp;24.45.&nbsp;Configuration of a repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    flatDir {
        name <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'localRepository'</span>
    }
}
repositories {
    localRepository {
        dirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib'</span>
    }
}
repositories.localRepository {
    dirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib'</span>
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:more_about_ivy_resolvers" class="section-anchor" href="#sub:more_about_ivy_resolvers"></a>24.6.9.&nbsp;More about Ivy resolvers</h3></div></div></div><p>Gradle is extremely flexible regarding repositories:
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There are many options for the protocol to communicate with the repository (e.g. filesystem, http, ssh, sftp ...)
                    </p></li><li class="listitem"><p>The protocol sftp currently only supports username/password-based authentication.
                    </p></li><li class="listitem"><p>Each repository can have its own layout.
                    </p></li></ul></div><p>Let's say, you declare a dependency on the <code class="literal">junit:junit:3.8.2</code> library.
                Now how does Gradle find it in the repositories? Somehow the dependency information has to be mapped to a
                path. In contrast to Maven, where this path is fixed, with Gradle you can define a pattern that defines
                what the path will look like. Here are some examples:
                <sup>[<a href="#ftn.N12C00" name="N12C00" class="footnote">13</a>]</sup>
            </p><pre class="programlisting">
// Maven2 layout (if a repository is marked as Maven2 compatible, the organization (group) is split into subfolders according to the dots.)
someroot/[organisation]/[module]/[revision]/[module]-[revision].[ext]

// Typical layout for an Ivy repository (the organization is not split into subfolder)
someroot/[organisation]/[module]/[revision]/[type]s/[artifact].[ext]

// Simple layout (the organization is not used, no nested folders.)
someroot/[artifact]-[revision].[ext]
</pre><p>To add any kind of repository (you can pretty easy write your own ones) you can do:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="fileSystemResolver"></a><p class="title"><b>Example&nbsp;24.46.&nbsp;Definition of a custom repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        ivyPattern <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$projectDir/repo/[organisation]/[module]-ivy-[revision].xml"</span>
        artifactPattern <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$projectDir/repo/[organisation]/[module]-[revision](-[classifier]).[ext]"</span>
    }
}
</pre></div></div><br class="example-break"><p>An overview of which Resolvers are offered by Ivy and thus also by Gradle can be found
                <a class="ulink" href="http://ant.apache.org/ivy/history/latest-milestone/settings/resolvers.html" target="_top">here</a>. With
                Gradle you just don't configure them via XML but directly via their API.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:dependency_resolution" class="section-anchor" href="#sec:dependency_resolution"></a>24.7.&nbsp;How dependency resolution works</h2></div></div></div><p>Gradle takes your dependency declarations and repository definitions and attempts to download all of your dependencies by a process called <span class="emphasis"><em>dependency resolution</em></span>.
            Below is a brief outline of how this process works.
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
                    Given a required dependency, Gradle first attempts to resolve the <span class="emphasis"><em>module</em></span> for that dependency. Each repository is inspected in order, searching
                    first for a <span class="emphasis"><em>module descriptor</em></span> file (POM or Ivy file) that indicates the presence of that module. If no module descriptor is found,
                    Gradle will search for the presence of the primary <span class="emphasis"><em>module artifact</em></span> file indicating that the module exists in the repository.
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If the dependency is declared as a dynamic version (like <code class="literal">1.+</code>), Gradle will resolve this to the newest available static version (like
                            <code class="literal">1.2</code>) in the repository. For Maven repositories, this is done using the <code class="literal">maven-metadata.xml</code>
                            file, while for Ivy repositories this is done by directory listing.
                        </p></li><li class="listitem"><p>If the module descriptor is a POM file that has a parent POM declared, Gradle will recursively attempt to resolve each of the parent modules for the POM.
                        </p></li></ul></div></li><li class="listitem"><p>Once each repository has been inspected for the module, Gradle will choose the 'best' one to use. This is done using the following criteria:
                    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">For a dynamic version, a 'higher' static version is preferred over a 'lower' version.</li><li class="listitem">Modules declared by a module descriptor file (Ivy or POM file) are preferred over modules that have an artifact file only.</li><li class="listitem">Modules from earlier repositories are preferred over modules in later repositories.</li></ul></div><p>
                </p><p>When the dependency is declared by a static version and a module descriptor file is found in a repository, there is no need to continue searching later
                    repositories and the remainder of the process is short-circuited.
                </p></li><li class="listitem"><p>All of the artifacts for the module are then requested from the <span class="emphasis"><em>same repository</em></span> that was chosen in the process above.
                </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:finetuning_the_dependency_resolution_process" class="section-anchor" href="#sec:finetuning_the_dependency_resolution_process"></a>24.8.&nbsp;Fine-tuning the dependency resolution process</h2></div></div></div><p>In most cases, Gradle's default dependency management will resolve the dependencies that you want in your build. In some cases, however, it can be necessary to tweak
            dependency resolution to ensure that your build receives exactly the right dependencies.
        </p><p>There are a number of ways that you can influence how Gradle resolves dependencies.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:forcing_modules" class="section-anchor" href="#sec:forcing_modules"></a>24.8.1.&nbsp;Forcing a particular module version</h3></div></div></div><p>Forcing a module version tells Gradle to always use a specific version for given dependency (transitive or not), overriding any version specified in a
                published module descriptor. This can be very useful when tackling version conflicts - for more information see <a class="xref" href="dependency_management.html#sub:version_conflicts">Section&nbsp;24.2.3, &ldquo;Resolve version conflicts&rdquo;</a>.
            </p><p>
                Force versions can also be used to deal with rogue metadata of transitive dependencies.
                If a transitive dependency has poor quality metadata that leads to problems at dependency resolution time, you can force Gradle to use a newer, fixed version of this dependency.
                For an example, see the <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a> class in the API documentation.
                Note that 'dependency resolve rules' (outlined below) provide a more powerful mechanism for replacing a broken module dependency. See <a class="xref" href="dependency_management.html#sec:blacklisting_version">the section called &ldquo;Blacklisting a particular version with a replacement&rdquo;</a>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:prefer_project_modules" class="section-anchor" href="#sec:prefer_project_modules"></a>24.8.2.&nbsp;Preferring modules that are part of the your build</h3></div></div></div><p>Preferring project modules tells Gradle to use the version of a module that is part of the build itself (as part of <a class="xref" href="multi_project_builds.html">Chapter&nbsp;25, <i>Multi-project Builds</i></a>
                or as includes in <a class="xref" href="composite_builds.html">Chapter&nbsp;10, <i>Composite builds</i></a>). This allows the easy inclusion of an individual fork (e.g. containing a bugfix) of a module - for more
                information see <a class="xref" href="dependency_management.html#sub:version_conflicts">Section&nbsp;24.2.3, &ldquo;Resolve version conflicts&rdquo;</a>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:dependency_resolve_rules" class="section-anchor" href="#sec:dependency_resolve_rules"></a>24.8.3.&nbsp;Using dependency resolve rules</h3></div></div></div><p>A dependency resolve rule is executed for each resolved dependency, and offers a powerful api for manipulating a requested dependency prior to that dependency being resolved.
                This feature is <a class="link" href="feature_lifecycle.html">incubating</a>, but currently offers the ability to change the group, name and/or version of a requested dependency,
                allowing a dependency to be substituted with a completely different module during resolution.
            </p><p>
                Dependency resolve rules provide a very powerful way to control the dependency resolution process, and can be used to implement all sorts of advanced
                patterns in dependency management. Some of these patterns are outlined below.
                For more information and code samples see the <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a> class in the API documentation.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:releasable_unit" class="section-anchor" href="#sec:releasable_unit"></a>Modelling releaseable units</h4></div></div></div><p>Often an organisation publishes a set of libraries with a single version; where the libraries are built, tested and published together.
                    These libraries form a 'releasable unit', designed and intended to be used as a whole. It does not make sense to use libraries from different releasable units together.
                </p><p>
                    But it is easy for transitive dependency resolution to violate this contract. For example:
                    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">module-a</code> depends on <code class="literal">releasable-unit:part-one:1.0</code></li><li class="listitem"><code class="literal">module-b</code> depends on <code class="literal">releasable-unit:part-two:1.1</code></li></ul></div><p>
                    A build depending on both <code class="literal">module-a</code> and <code class="literal">module-b</code> will obtain different versions of libraries within the releasable unit.
                </p><p>
                    Dependency resolve rules give you the power to enforce releasable units in your build.
                    Imagine a releasable unit defined by all libraries that have 'org.gradle' group. We can force all of these libraries to use a consistent version:
                    </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="releasable-unit"></a><p class="title"><b>Example&nbsp;24.47.&nbsp;Forcing consistent version for a group of libraries</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.requested.group == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.gradle'</span>) {
            details.useVersion <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.4'</span>
        }
    }
}
</pre></div></div><p><br class="example-break">
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:custom_versioning_scheme" class="section-anchor" href="#sec:custom_versioning_scheme"></a>Implement a custom versioning scheme</h4></div></div></div><p>
                    In some corporate environments, the list of module versions that can be declared in Gradle builds is maintained and audited externally.
                    Dependency resolve rules provide a neat implementation of this pattern:
                    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">In the build script, the developer declares dependencies with the module group and name, but uses a placeholder version, for example: '<code class="literal">default</code>'.</li><li class="listitem">The 'default' version is resolved to a specific version via a dependency resolve rule, which looks up the version in a corporate catalog of approved modules.</li></ul></div><p>

                    This rule implementation can be neatly encapsulated in a corporate plugin, and shared across all builds within the organisation.
                    </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="custom-versioning-scheme"></a><p class="title"><b>Example&nbsp;24.48.&nbsp;Using a custom versioning scheme</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.requested.version == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'default'</span>) {
            def version = findDefaultVersionInCatalog(details.requested.group, details.requested.name)
            details.useVersion version
        }
    }
}

def findDefaultVersionInCatalog(String group, String name) {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">//some custom logic that resolves the default version into a specific version</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"1.0"</span>
}
</pre></div></div><p><br class="example-break">
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:blacklisting_version" class="section-anchor" href="#sec:blacklisting_version"></a>Blacklisting a particular version with a replacement</h4></div></div></div><p>
                    Dependency resolve rules provide a mechanism for blacklisting a particular version of a dependency and providing a replacement version.
                    This can be useful if a certain dependency version is broken and should not be used,
                    where a dependency resolve rule causes this version to be replaced with a known good version.
                    One example of a broken module is one that declares a dependency on a library that cannot be found in any of the public repositories,
                    but there are many other reasons why a particular module version is unwanted and a different version is preferred.
                </p><p>
                    In example below, imagine that version <code class="literal">1.2.1</code> contains important fixes and should always be used in preference to <code class="literal">1.2</code>.
                    The rule provided will enforce just this: any time version <code class="literal">1.2</code> is encountered it will be replaced with <code class="literal">1.2.1</code>.
                    Note that this is different from a forced version as described above, in that any other versions of this module would not be affected.
                    This means that the 'newest' conflict resolution strategy would still select version <code class="literal">1.3</code> if this version was also pulled transitively.
                    </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="blacklisting_version"></a><p class="title"><b>Example&nbsp;24.49.&nbsp;Blacklisting a version with a replacement</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.requested.group == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.software'</span> &amp;&amp; details.requested.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'some-library'</span> &amp;&amp; details.requested.version == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.2'</span>) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">//prefer different version which contains some necessary fixes</span>
            details.useVersion <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.2.1'</span>
        }
    }
}
</pre></div></div><p><br class="example-break">
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:module_substitution" class="section-anchor" href="#sec:module_substitution"></a>Substituting a dependency module with a compatible replacement</h4></div></div></div><p>At times a completely different module can serve as a replacement for a requested module dependency.
                    Examples include using '<code class="literal">groovy</code>' in place of '<code class="literal">groovy-all</code>', or using '<code class="literal">log4j-over-slf4j</code>' instead of '<code class="literal">log4j</code>'.
                    Starting with Gradle 1.5 you can make these substitutions using dependency resolve rules:
                    </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="module_substitution"></a><p class="title"><b>Example&nbsp;24.50.&nbsp;Changing dependency group and/or name at the resolution</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.requested.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'groovy-all'</span>) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">//prefer 'groovy' over 'groovy-all':</span>
            details.useTarget group: details.requested.group, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'groovy'</span>, version: details.requested.version
        }
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.requested.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'log4j'</span>) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">//prefer 'log4j-over-slf4j' over 'log4j', with fixed version:</span>
            details.useTarget <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.slf4j:log4j-over-slf4j:1.7.10"</span>
        }
    }
}
</pre></div></div><p><br class="example-break">
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="dependency_substitution_rules" class="section-anchor" href="#dependency_substitution_rules"></a>24.8.4.&nbsp;Dependency Substitution Rules</h3></div></div></div><p>
                Dependency substitution rules work similarly to dependency resolve rules.  In fact, many capabilities of dependency resolve rules
                can be implemented with dependency substitution rules.  They allow project and module dependencies to be transparently substituted with
                specified replacements.
                Unlike dependency resolve rules, dependency substitution rules allow project and module dependencies to be substituted interchangeably.
            </p><div class="note"><p>
                    <span class="emphasis"><em>NOTE: Adding a dependency substitution rule to a configuration changes the timing of when that configuration is resolved.</em></span>
                    Instead of being resolved on first use, the configuration is instead resolved when the task graph is being constructed. This can have unexpected
                    consequences if the configuration is being further modified during task execution, or if the configuration relies on modules that are published during
                    execution of another task.
                </p><p>
                    To explain:
                    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A <code class="literal">Configuration</code> can be declared as an input to any Task, and that configuration can include project dependencies when it is resolved.</li><li class="listitem">If a project dependency is an input to a Task (via a configuration), then tasks to built the project artifacts must be added to the task dependencies.</li><li class="listitem">In order to determine the project dependencies that are inputs to a task, Gradle needs to resolve the <code class="literal">Configuration</code> inputs.</li><li class="listitem">Because the Gradle task graph is fixed once task execution has commenced, Gradle needs to perform this resolution prior to executing any tasks.</li></ul></div><p>
                </p><p>
                    In the absence of dependency substitution rules, Gradle knows that an external module dependency will never transitively reference a project dependency.
                    This makes it easy to determine the full set of project dependencies for a configuration through simple graph traversal.
                    With this functionality, Gradle can no longer make this assumption, and must perform a full resolve in order to determine the project dependencies.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:module_to_project_substitution" class="section-anchor" href="#sec:module_to_project_substitution"></a>Substituting an external module dependency with a project dependency</h4></div></div></div><p>
                    One use case for dependency substitution is to use a locally developed version of a module in place of one that is downloaded from
                    an external repository. This could be useful for testing a local, patched version of a dependency.
                </p><p>
                    The module to be replaced can be declared with or without a version specified.
                </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="module_to_project_substitution"></a><p class="title"><b>Example&nbsp;24.51.&nbsp;Substituting a module with a project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.dependencySubstitution {
        substitute module(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.utils:api"</span>) with project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":api"</span>)
        substitute module(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.utils:util:2.5"</span>) with project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":util"</span>)
    }
}
</pre></div></div><br class="example-break"><p>
                    Note that a project that is substituted must be included in the multi-project build (via settings.gradle).  Dependency substitution
                    rules take care of replacing the module dependency with the project dependency and wiring up any task dependencies,
                    but do not implicitly include the project in the build.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:project_to_module_substitution" class="section-anchor" href="#sec:project_to_module_substitution"></a>Substituting a project dependency with a module replacement</h4></div></div></div><p>
                    Another way to use substitution rules is to replace a project dependency with a module in a multi-project build.
                    This can be useful to speed up development with a large multi-project build, by allowing a subset of the project
                    dependencies to be downloaded from a repository rather than being built.
                </p><p>
                    The module to be used as a replacement must be declared with a version specified.
                </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="project_to_module_substitution"></a><p class="title"><b>Example&nbsp;24.52.&nbsp;Substituting a project with a module</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.dependencySubstitution {
        substitute project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":api"</span>) with module(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.utils:api:1.3"</span>)
    }
}
</pre></div></div><br class="example-break"><p>
                    When a project dependency has been replaced with a module dependency, that project is still included in the overall multi-project build.
                    However, tasks to build the replaced dependency will not be executed in order to build the resolve the depending <code class="literal">Configuration</code>.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:conditional_dependency_substitution" class="section-anchor" href="#sec:conditional_dependency_substitution"></a>Conditionally substituting a dependency</h4></div></div></div><p>
                    A common use case for dependency substitution is to allow more flexible assembly of sub-projects within a multi-project build.
                    This can be useful for developing a local, patched version of an external dependency or for building a subset of the modules within
                    a large multi-project build.
                </p><p>
                    The following example uses a dependency substitution rule to replace any module dependency with the group "org.example", but
                    only if a local project matching the dependency name can be located.
                </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="project_substitution"></a><p class="title"><b>Example&nbsp;24.53.&nbsp;Conditionally substituting a dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.dependencySubstitution.all { DependencySubstitution dependency -&gt;
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (dependency.requested <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">instanceof</span> ModuleComponentSelector &amp;&amp; dependency.requested.group == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.example"</span>) {
            def targetProject = findProject(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":${dependency.requested.module}"</span>)
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (targetProject != null) {
                dependency.useTarget targetProject
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>
                    Note that a project that is substituted must be included in the multi-project build (via settings.gradle).  Dependency substitution
                    rules take care of replacing the module dependency with the project dependency, but do not implicitly include the project in the build.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:configuration_defaults" class="section-anchor" href="#sec:configuration_defaults"></a>24.8.5.&nbsp;Specifying default dependencies for a configuration</h3></div></div></div><p>
                A configuration can be configured with default dependencies to be used if no dependencies are explicitly set for the configuration.
                A primary use case of this functionality is for developing plugins that make use of versioned tools that the user might override.  By specifying
                default dependencies, the plugin can use a default version of the tool only if the user has not specified a particular version to use.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="configuration_default_dependencies"></a><p class="title"><b>Example&nbsp;24.54.&nbsp;Specifying default dependencies on a configuration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    pluginTool {
        defaultDependencies { dependencies -&gt;
            dependencies.add(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">this</span>.project.dependencies.create(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.gradle:my-util:1.0"</span>))
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="ivy_dynamic_resolve_mode" class="section-anchor" href="#ivy_dynamic_resolve_mode"></a>24.8.6.&nbsp;Enabling Ivy dynamic resolve mode</h3></div></div></div><p>
                Gradle's Ivy repository implementations support the equivalent to Ivy's dynamic resolve mode. Normally, Gradle will use the <code class="literal">rev</code> attribute for each dependency
                definition included in an <code class="filename">ivy.xml</code> file. In dynamic resolve mode, Gradle will instead prefer the <code class="literal">revConstraint</code> attribute over the
                <code class="literal">rev</code> attribute for a given dependency definition. If the <code class="literal">revConstraint</code> attribute is not present, the <code class="literal">rev</code> attribute is used
                instead.
            </p><p>To enable dynamic resolve mode, you need to set the appropriate option on the repository definition. A couple of examples are shown below. Note that dynamic resolve mode is only
                available for Gradle's Ivy repositories. It is not available for Maven repositories, or custom Ivy <code class="classname">DependencyResolver</code> implementations.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="dynamicResolveMode"></a><p class="title"><b>Example&nbsp;24.55.&nbsp;Enabling dynamic resolve mode</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Can enable dynamic resolve mode when you define the repository</span>
repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
        resolve.dynamicMode = true
    }
}

<span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Can use a rule instead to enable (or disable) dynamic resolve mode for all repositories</span>
repositories.withType(IvyArtifactRepository) {
    resolve.dynamicMode = true
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="component_metadata_rules" class="section-anchor" href="#component_metadata_rules"></a>24.8.7.&nbsp;Component metadata rules</h3></div></div></div><p>Each module (also called <span class="emphasis"><em>component</em></span>) has metadata associated with it, such as its group, name, version, dependencies, and so on.
                This metadata typically originates in the module's descriptor. Metadata rules allow certain parts of a module's metadata to be manipulated
                from within the build script. They take effect after a module's descriptor has been downloaded, but before it has been selected among all candidate versions.
                This makes metadata rules another instrument for customizing dependency resolution.
            </p><p>
                One piece of module metadata that Gradle understands is a module's <span class="emphasis"><em>status scheme</em></span>. This concept, also known from Ivy, models the different
                levels of maturity that a module transitions through over time. The default status scheme, ordered from least to most mature status, is <code class="literal">integration</code>,
                <code class="literal">milestone</code>, <code class="literal">release</code>. Apart from a status scheme, a module also has a (current) <span class="emphasis"><em>status</em></span>, which must be one of
                the values in its status scheme. If not specified in the (Ivy) descriptor, the status defaults to <code class="literal">integration</code> for Ivy modules and Maven snapshot modules,
                and <code class="literal">release</code> for Maven modules that aren't snapshots.
            </p><p>
                A module's status and status scheme are taken into consideration when a <code class="literal">latest</code> version selector is resolved. Specifically, <code class="literal">latest.someStatus</code>
                will resolve to the highest module version that has status <code class="literal">someStatus</code> or a more mature status. For example, with the default status scheme in place,
                <code class="literal">latest.integration</code> will select the highest module version regardless of its status (because <code class="literal">integration</code> is the least mature status),
                whereas <code class="literal">latest.release</code> will select the highest module version with status <code class="literal">release</code>. Here is what this looks like in code:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="latestSelector"></a><p class="title"><b>Example&nbsp;24.56.&nbsp;'Latest' version selector</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    config1 <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.sample:client:latest.integration"</span>
    config2 <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.sample:client:latest.release"</span>
}

task listConfigs {
    doLast {
        configurations.config1.each { println it.name }
        println()
        configurations.config2.each { println it.name }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q listConfigs</code></strong></p><pre class="screen">&gt; gradle -q listConfigs
client-1.5.jar

client-1.4.jar</pre></div></div><br class="example-break"><p>
                The next example demonstrates <code class="literal">latest</code> selectors based on a custom status scheme declared in a component metadata rule that applies to all modules:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="customStatusScheme"></a><p class="title"><b>Example&nbsp;24.57.&nbsp;Custom status scheme</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    config3 <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.sample:api:latest.silver"</span>
    components {
        all { ComponentMetadataDetails details -&gt;
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.id.group == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.sample"</span> &amp;&amp; details.id.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"api"</span>) {
                details.statusScheme = [<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"bronze"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"silver"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"gold"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"platinum"</span>]
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>
                Component metadata rules can be applied to a specified module.  Modules must be specified in the form of "group:module".
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="customStatusSchemeModule"></a><p class="title"><b>Example&nbsp;24.58.&nbsp;Custom status scheme by module</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    config4 <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.sample:lib:latest.prod"</span>
    components {
        withModule(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.sample:lib'</span>) { ComponentMetadataDetails details -&gt;
            details.statusScheme = [<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"int"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"rc"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"prod"</span>]
        }
    }
}
</pre></div></div><br class="example-break"><p>
                Gradle can also create component metadata rules utilizing Ivy-specific metadata for modules resolved from an Ivy repository.
                Values from the Ivy descriptor are made available via the <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ivy/IvyModuleDescriptor.html" target="_top"><code class="classname">IvyModuleDescriptor</code></a> interface.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="ivyComponentMetadataRule"></a><p class="title"><b>Example&nbsp;24.59.&nbsp;Ivy component metadata rule</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    config6 <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.sample:lib:latest.rc"</span>
    components {
        withModule(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.sample:lib"</span>) { ComponentMetadataDetails details, IvyModuleDescriptor ivyModule -&gt;
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (ivyModule.branch == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'testing'</span>) {
                details.status = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"rc"</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>
                Note that any rule that declares specific arguments must <span class="emphasis"><em>always</em></span> include a <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ComponentMetadataDetails.html" target="_top"><code class="classname">ComponentMetadataDetails</code></a> argument
                as the first argument. The second Ivy metadata argument is optional.
            </p><p>
                Component metadata rules can also be defined using a <span class="emphasis"><em>rule source</em></span> object.  A rule source object
                is any object that contains exactly one method that defines the rule action and is annotated with <code class="literal">@Mutate</code>.
            </p><p>
                This method:
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">must return void.</li><li class="listitem">must have <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ComponentMetadataDetails.html" target="_top"><code class="classname">ComponentMetadataDetails</code></a> as the first argument.</li><li class="listitem">may have an additional parameter of type <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ivy/IvyModuleDescriptor.html" target="_top"><code class="classname">IvyModuleDescriptor</code></a>.</li></ul></div><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="ruleSourceComponentMetadataRule"></a><p class="title"><b>Example&nbsp;24.60.&nbsp;Rule source component metadata rule</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    config5 <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.sample:api:latest.gold"</span>
    components {
        withModule(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.sample:api'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> CustomStatusRule())
    }
}

<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> CustomStatusRule {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@Mutate</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">void</span> setStatusScheme(ComponentMetadataDetails details) {
        details.statusScheme = [<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"bronze"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"silver"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"gold"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"platinum"</span>]
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="component_selection_rules" class="section-anchor" href="#component_selection_rules"></a>24.8.8.&nbsp;Component Selection Rules</h3></div></div></div><p>
                Component selection rules may influence which component instance should be selected when multiple versions are available that match a version selector.
                Rules are applied against every available version and allow the version to be explicitly rejected by rule.
                This allows Gradle to ignore any component instance that does not satisfy conditions set by the rule. Examples include:
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">For a dynamic version like '1.+' certain versions may be explicitly rejected from selection</li><li class="listitem">For a static version like '1.4' an instance may be rejected based on extra component metadata such as the Ivy branch attribute, allowing an instance from a subsequent repository to be used.</li></ul></div><p>
                Rules are configured via the <a class="ulink" href="../dsl/org.gradle.api.artifacts.ComponentSelectionRules.html" target="_top"><code class="classname">ComponentSelectionRules</code></a> object.  Each rule configured
                will be called with a <a class="ulink" href="../dsl/org.gradle.api.artifacts.ComponentSelection.html" target="_top"><code class="classname">ComponentSelection</code></a> object as an argument which contains information
                about the candidate version being considered.
                Calling <a class="ulink" href="../dsl/org.gradle.api.artifacts.ComponentSelection.html#org.gradle.api.artifacts.ComponentSelection:reject(java.lang.String)" target="_top"><code class="classname">ComponentSelection.reject(java.lang.String)</code></a> causes the given candidate version to be explicitly rejected,
                in which case the candidate will not be considered for the selector.
            </p><p>
                The following example shows a rule that disallows a particular version of a module but allows the dynamic version to
                choose the next best candidate.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="componentSelectionRulesReject"></a><p class="title"><b>Example&nbsp;24.61.&nbsp;Component selection rule</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    rejectConfig {
        resolutionStrategy {
            componentSelection {
                <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Accept the highest version matching the requested version that isn't '1.5'</span>
                all { ComponentSelection selection -&gt;
                    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (selection.candidate.group == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.sample'</span> &amp;&amp; selection.candidate.module == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'api'</span> &amp;&amp; selection.candidate.version == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.5'</span>) {
                        selection.reject(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"version 1.5 is broken for 'org.sample:api'"</span>)
                    }
                }
            }
        }
    }
}

dependencies {
    rejectConfig <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.sample:api:1.+"</span>
}
</pre></div></div><br class="example-break"><p>
                Note that version selection is applied starting with the highest version first.  The version selected will be the first version
                found that all component selection rules accept.  A version is considered accepted no rule explicitly rejects it.
            </p><p>
                Similarly, rules can be targeted at specific modules.  Modules must be specified in the form of "group:module".
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="componentSelectionRulesTarget"></a><p class="title"><b>Example&nbsp;24.62.&nbsp;Component selection rule with module target</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    targetConfig {
        resolutionStrategy {
            componentSelection {
                withModule(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.sample:api"</span>) { ComponentSelection selection -&gt;
                    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (selection.candidate.version == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"1.5"</span>) {
                        selection.reject(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"version 1.5 is broken for 'org.sample:api'"</span>)
                    }
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>
                Component selection rules can also consider component metadata when selecting a version.  Possible metadata arguments that can be considered are
                <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ComponentMetadata.html" target="_top"><code class="classname">ComponentMetadata</code></a> and <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ivy/IvyModuleDescriptor.html" target="_top"><code class="classname">IvyModuleDescriptor</code></a>.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="componentSelectionRulesMetadata"></a><p class="title"><b>Example&nbsp;24.63.&nbsp;Component selection rule with metadata</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    metadataRulesConfig {
        resolutionStrategy {
            componentSelection {
                <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Reject any versions with a status of 'experimental'</span>
                all { ComponentSelection selection, ComponentMetadata metadata -&gt;
                    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (selection.candidate.group == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.sample'</span> &amp;&amp; metadata.status == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'experimental'</span>) {
                        selection.reject(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"don't use experimental candidates from 'org.sample'"</span>)
                    }
                }
                <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Accept the highest version with either a "release" branch or a status of 'milestone'</span>
                withModule(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.sample:api'</span>) { ComponentSelection selection, IvyModuleDescriptor descriptor, ComponentMetadata metadata -&gt;
                    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (descriptor.branch != <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"release"</span> &amp;&amp; metadata.status != <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'milestone'</span>) {
                        selection.reject(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"'org.sample:api' must have testing branch or milestone status"</span>)
                    }
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>
                Note that a <a class="ulink" href="../dsl/org.gradle.api.artifacts.ComponentSelection.html" target="_top"><code class="classname">ComponentSelection</code></a> argument is <span class="emphasis"><em>always</em></span> required as the first
                parameter when declaring a component selection rule with additional Ivy metadata parameters, but the metadata parameters can be declared
                in any order.
            </p><p>
                Lastly, component selection rules can also be defined using a <span class="emphasis"><em>rule source</em></span> object.  A rule source object
                is any object that contains exactly one method that defines the rule action and is annotated with <code class="literal">@Mutate</code>.
            </p><p>
                This method:
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">must return void.</li><li class="listitem">must have <a class="ulink" href="../dsl/org.gradle.api.artifacts.ComponentSelection.html" target="_top"><code class="classname">ComponentSelection</code></a> as the first argument.</li><li class="listitem">may have additional parameters of type <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ComponentMetadata.html" target="_top"><code class="classname">ComponentMetadata</code></a> and/or <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ivy/IvyModuleDescriptor.html" target="_top"><code class="classname">IvyModuleDescriptor</code></a>.</li></ul></div><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="componentSelectionRulesRuleSource"></a><p class="title"><b>Example&nbsp;24.64.&nbsp;Component selection rule using a rule source object</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">class</span> RejectTestBranch {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-annotation">@Mutate</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">void</span> evaluateRule(ComponentSelection selection, IvyModuleDescriptor ivy) {
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (ivy.branch == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"test"</span>) {
            selection.reject(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"reject test branch"</span>)
        }
    }
}

configurations {
    ruleSourceConfig {
        resolutionStrategy {
            componentSelection {
                all <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> RejectTestBranch()
            }
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:module_replacement" class="section-anchor" href="#sec:module_replacement"></a>24.8.9.&nbsp;Module replacement rules</h3></div></div></div><p>
                Module replacement rules allow a build to declare that a legacy library has been replaced by a new one.
                A good example when a new library replaced a legacy one is the "google-collections" -&gt; "guava" migration.
                The team that created google-collections decided to change the module name from "com.google.collections:google-collections" into "com.google.guava:guava".
                This a legal scenario in the industry: teams need to be able to change the names of products they maintain, including the module coordinates.
                Renaming of the module coordinates has impact on conflict resolution.
            </p><p>
                To explain the impact on conflict resolution, let's consider the "google-collections" -&gt; "guava" scenario.
                It may happen that both libraries are pulled into the same dependency graph.
                For example, "our" project depends on guava but some of our dependencies pull in a legacy version of google-collections.
                This can cause runtime errors, for example during test or application execution.
                Gradle does not automatically resolve the google-collections VS guava conflict because it is not considered as a "version conflict".
                It's because the module coordinates for both libraries are completely different and conflict resolution is activated when
                "group" and "name" coordinates are the same but there are different versions available in the dependency graph
                (for more info, please refer to the section on conflict resolution).
                Traditional remedies to this problem are:
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Declare exclusion rule to avoid pulling in "google-collections" to graph. It is probably the most popular approach.</li><li class="listitem">Avoid dependencies that pull in legacy libraries.</li><li class="listitem">Upgrade the dependency version if the new version no longer pulls in a legacy library.</li><li class="listitem">Downgrade to "google-collections". It's not recommended, just mentioned for completeness.</li></ul></div><p>
                Traditional approaches work but they are not general enough.
                For example, an organisation wants to resolve the google-collections VS guava conflict resolution problem in all projects.
                Starting from Gradle 2.2 it is possible to declare that certain module was replaced by other.
                This enables organisations to include the information about module replacement in the corporate plugin suite and resolve the problem
                holistically for all Gradle-powered projects in the enterprise.
                </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="module_replacement_declaration"></a><p class="title"><b>Example&nbsp;24.65.&nbsp;Declaring module replacement</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    modules {
        module(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"com.google.collections:google-collections"</span>) {
            replacedBy(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"com.google.guava:guava"</span>)
        }
    }
}
</pre></div></div><p><br class="example-break">
                For more examples and detailed API, please refer to the DSL reference for <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.ComponentMetadataHandler.html" target="_top"><code class="classname">ComponentMetadataHandler</code></a>.
            </p><p>
                What happens when we declare that "google-collections" are replaced by "guava"?
                Gradle can use this information for conflict resolution.
                Gradle will consider every version of "guava" newer/better than any version of "google-collections".
                Also, Gradle will ensure that only guava jar is present in the classpath / resolved file list.
                Please note that if only "google-collections" appears in the dependency graph (e.g. no "guava")
                Gradle will not eagerly replace it with "guava".
                Module replacement is an information that Gradle uses for resolving conflicts. If there is no conflict
                (e.g. only "google-collections" or only "guava" in the graph) the replacement information is not used.
            </p><p>
                Currently it is not possible to declare that certain modules is replaced by a set of modules.
                However, it is possible to declare that multiple modules are replaced by a single module.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:dependency_cache" class="section-anchor" href="#sec:dependency_cache"></a>24.9.&nbsp;The dependency cache</h2></div></div></div><p>Gradle contains a highly sophisticated dependency caching mechanism, which seeks to minimise the number of remote requests made in
            dependency resolution, while striving to guarantee that the results of dependency resolution are correct and reproducible.
        </p><p>
            The Gradle dependency cache consists of 2 key types of storage:
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A file-based store of downloaded artifacts, including binaries like jars as well as raw downloaded meta-data like POM files and Ivy files.
                    The storage path for a downloaded artifact includes the SHA1 checksum, meaning that 2 artifacts with the same name but different content can easily be cached.
                </p></li><li class="listitem"><p>A binary store of resolved module meta-data, including the results of resolving dynamic versions, module descriptors, and artifacts.</p></li></ul></div><p>Separating the storage of downloaded artifacts from the cache metadata permits us to do some very powerful things with our cache that would be difficult with a transparent,
            file-only cache layout.
        </p><p>The Gradle cache does not allow the local cache to hide problems and create other mysterious and difficult to debug behavior
            that has been a challenge with many build tools. This new behavior is implemented in a bandwidth and storage efficient way.
            In doing so, Gradle enables reliable and reproducible enterprise builds.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:cache_features" class="section-anchor" href="#sec:cache_features"></a>24.9.1.&nbsp;Key features of the Gradle dependency cache</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:cache_metadata" class="section-anchor" href="#sub:cache_metadata"></a>Separate metadata cache</h4></div></div></div><p>
                    Gradle keeps a record of various aspects of dependency resolution in binary format in the metadata cache.
                    The information stored in the metadata cache includes:
                    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The result of resolving a dynamic version (e.g. <code class="literal">1.+</code>) to a concrete version (e.g. <code class="literal">1.2</code>).</li><li class="listitem">The resolved module metadata for a particular module, including module artifacts and module dependencies.</li><li class="listitem">The resolved artifact metadata for a particular artifact, including a pointer to the downloaded artifact file.</li><li class="listitem">The
                            <span class="emphasis"><em>absence</em></span>
                            of a particular module or artifact in a particular repository,
                            eliminating repeated attempts to access a resource that does not exist.
                        </li></ul></div><p>
                    Every entry in the metadata cache includes a record of the repository that provided the information as well as a timestamp that can be used for cache expiry.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:cache_repository_independence" class="section-anchor" href="#sub:cache_repository_independence"></a>Repository caches are independent</h4></div></div></div><p>As described above, for each repository there is a separate metadata cache. A repository is identified by its URL, type and layout.
                    If a module or artifact has not been previously resolved from <span class="emphasis"><em>this repository</em></span>, Gradle will attempt to resolve the module
                    against the repository. This will always involve a remote lookup on the repository, however in many cases no download will be required (see<a class="xref" href="dependency_management.html#sub:cache_artifact_reuse">the section called &ldquo;Artifact reuse&rdquo;</a>, below).
                </p><p>Dependency resolution will fail if the required artifacts are not available in any repository specified by the build,
                    even if the local cache has a copy of this artifact which was retrieved from a different repository.
                    Repository independence allows builds to be isolated from each other in an advanced way that no build tool has done before.
                    This is a key feature to create builds that are reliable and reproducible in any environment.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:cache_artifact_reuse" class="section-anchor" href="#sub:cache_artifact_reuse"></a>Artifact reuse</h4></div></div></div><p>Before downloading an artifact, Gradle tries to determine the checksum of the required artifact by downloading the sha file associated
                    with that artifact. If the checksum can be retrieved, an artifact is not downloaded if an artifact already exists with the same id and checksum.
                    If the checksum cannot be retrieved from the remote server, the artifact will be downloaded (and ignored if it matches an existing artifact).
                </p><p>As well as considering artifacts downloaded from a different repository, Gradle will also attempt to reuse artifacts found in the local Maven Repository.
                    If a candidate artifact has been downloaded by Maven, Gradle will use this artifact if it can be verified to match the checksum declared by the remote server.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:cache_checksum_storage" class="section-anchor" href="#sub:cache_checksum_storage"></a>Checksum based storage</h4></div></div></div><p>
                    It is possible for different repositories to provide a different binary artifact in response to the same artifact identifier. This is often the case with Maven SNAPSHOT
                    artifacts, but can also be true for any artifact which is republished without changing it's identifier.
                    By caching artifacts based on their SHA1 checksum, Gradle is able to maintain multiple versions of the same artifact. This means that when resolving against
                    one repository Gradle will never overwrite the cached artifact file from a different repository. This is done without requiring a separate artifact file store per repository.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:cache_locking" class="section-anchor" href="#sub:cache_locking"></a>Cache Locking</h4></div></div></div><p>
                    The Gradle dependency cache uses file-based locking to ensure that it can safely be used by multiple Gradle processes concurrently. The lock is held whenever the binary
                    meta-data store is being read or written, but is released for slow operations such as downloading remote artifacts.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:cache_command_line_options" class="section-anchor" href="#sec:cache_command_line_options"></a>24.9.2.&nbsp;Command line options to override caching</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:cache_offline" class="section-anchor" href="#sub:cache_offline"></a>Offline</h4></div></div></div><p>The <code class="literal">--offline</code>
                    command line switch tells Gradle to always use dependency modules from the cache, regardless if they are due to be checked again.
                    When running with offline, Gradle will never attempt to access the network to perform dependency resolution.
                    If required modules are not present in the dependency cache, build execution will fail.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:cache_refresh" class="section-anchor" href="#sub:cache_refresh"></a>Refresh</h4></div></div></div><p>At times, the Gradle Dependency Cache can be out of sync with the actual state of the configured repositories. Perhaps a repository was initially misconfigured,
                    or perhaps a &ldquo;non-changing&rdquo; module was published incorrectly. To refresh all dependencies in the dependency cache, use the
                    <code class="literal">--refresh-dependencies</code> option on the command line.
                </p><p>The <code class="literal">--refresh-dependencies</code> option tells Gradle to ignore all cached entries for resolved modules and artifacts.
                    A fresh resolve will be performed against all configured repositories, with dynamic versions recalculated, modules refreshed, and artifacts downloaded.
                    However, where possible Gradle will check if the previously downloaded artifacts are valid before downloading again.
                    This is done by comparing published SHA1 values in the repository with the SHA1 values for existing downloaded artifacts.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:controlling_caching" class="section-anchor" href="#sec:controlling_caching"></a>24.9.3.&nbsp;Fine-tuned control over dependency caching</h3></div></div></div><p>You can fine-tune certain aspects of caching using the
                <code class="literal">ResolutionStrategy</code>
                for a configuration.
            </p><p>By default, Gradle caches dynamic versions for 24 hours. To change how long Gradle will cache the resolved version for a dynamic version, use:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="dynamic-version-cache-control"></a><p class="title"><b>Example&nbsp;24.66.&nbsp;Dynamic version cache control</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.cacheDynamicVersionsFor <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">10</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'minutes'</span>
}
</pre></div></div><br class="example-break"><p>By default, Gradle caches changing modules for 24 hours. To change how long Gradle will cache the meta-data and artifacts for a changing module, use:
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="changing-module-cache-control"></a><p class="title"><b>Example&nbsp;24.67.&nbsp;Changing module cache control</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.cacheChangingModulesFor <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">4</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hours'</span>
}
</pre></div></div><br class="example-break"><p>For more details, take a look at the API documentation for <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:strategies_of_transitive_dependency_management" class="section-anchor" href="#sec:strategies_of_transitive_dependency_management"></a>24.10.&nbsp;Strategies for transitive dependency management</h2></div></div></div><p>Many projects rely on the <a class="ulink" href="https://repo1.maven.org/maven2" target="_top">Maven Central repository</a>. This is not without problems.
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The Maven Central repository can be down or can be slow to respond.
                </p></li><li class="listitem"><p>The POM files of many popular projects specify dependencies or other configuration that
                are just plain wrong (for instance, the POM file of the &ldquo;<code class="literal">commons-httpclient-3.0</code>&rdquo;
                module declares JUnit as a runtime dependency).
                </p></li><li class="listitem"><p>For many projects there is not one right set of dependencies (as more or less imposed by the POM format).
                </p></li></ul></div><p>If your project relies on the Maven Central repository you are likely to need an additional custom repository,
            because:
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You might need dependencies that are not uploaded to Maven Central yet.
                </p></li><li class="listitem"><p>You want to deal properly with invalid metadata in a Maven Central POM file.
                </p></li><li class="listitem"><p>You don't want to expose people to the downtimes or slow response of Maven Central, if they
                just want to build your project.
                </p></li></ul></div><p>It is not a big deal to set-up a custom repository,
            <sup>[<a href="#ftn.N12FA9" name="N12FA9" class="footnote">14</a>]</sup>
            but it can be tedious to keep it up to date. For a new version, you always have to create the new XML
            descriptor and the directories. Your custom repository is another infrastructure element which might
            have downtimes and needs to be updated. To enable historical builds, you need to keep all the past
            libraries, not to mention a backup of these. It is another layer of indirection. Another source of information
            you have to lookup. All this is not really a big deal but in its sum it has an impact. Repository managers like
            Artifactory or Nexus make this easier, but most open source projects don't usually have a host for those products.
            This is changing with new services like <a class="ulink" href="http://bintray.com" target="_top">Bintray</a> that let developers host and
            distribute their release binaries using a self-service repository platform. Bintray also supports sharing approved artifacts
            though the <a class="ulink" href="http://jcenter.bintray.com" target="_top">JCenter</a> public repository to provide a single resolution address for
            all popular OSS Java artifacts (see <a class="xref" href="dependency_management.html#sub:maven_jcenter">Section&nbsp;24.6.2, &ldquo;Maven JCenter repository&rdquo;</a>).
        </p><p>This is a common reason why many projects prefer to store their libraries in their version control system. This
            approach is fully supported by Gradle. The libraries can be stored in a flat directory without any XML module
            descriptor files. Yet Gradle offers complete transitive dependency management. You can use either client module
            dependencies to express the dependency relations, or artifact dependencies in case a first level dependency has no
            transitive dependencies. People can check out such a project from your source code control system and
            have everything necessary to build it.
        </p><p>If you are working with a distributed version control system like Git you probably don't want to
            use the version control system to store libraries as people check out the whole history. But even here the flexibility
            of Gradle can make your life easier. For example, you can use a shared flat directory without XML descriptors and
            yet you can have full transitive dependency management, as described above.
        </p><p>You could also have a mixed strategy. If your main concern is bad metadata in the POM file and maintaining custom XML descriptors,
            then <span class="emphasis"><em>Client Modules</em></span> offer an alternative. However, you can still use a Maven2 repo or your custom repository as a repository for
            <span class="emphasis"><em>jars only</em></span> and still enjoy <span class="emphasis"><em>transitive</em></span> dependency management. Or
            you can only provide client modules for POMs with bad metadata. For the jars and the correct POMs you
            still use the remote repository.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sub:implicit_transitive_dependencies" class="section-anchor" href="#sub:implicit_transitive_dependencies"></a>24.10.1.&nbsp;Implicit transitive dependencies</h3></div></div></div><p>There is another way to deal with transitive dependencies <span class="emphasis"><em>without</em></span> XML
            descriptor files. You can do this with Gradle, but we don't recommend it. We mention it for the sake of
            completeness and comparison with other build tools.
            </p><p>The trick is to use only artifact dependencies and group them in lists. This will directly express
                your first level dependencies and your transitive dependencies (see <a class="xref" href="dependency_management.html#para:notation_collections">Section&nbsp;24.4.8, &ldquo;Optional attributes&rdquo;</a>).
                The problem with this is that Gradle dependency management will see this as specifying all
                dependencies as first level dependencies. The dependency reports won't show your real dependency
                graph and the <code class="literal">compile</code> task uses all dependencies, not just the first level
                dependencies. All in all, your build is less maintainable and reliable than it could be when using
                client modules, and you don't gain anything.
            </p></div></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N126BE" name="ftn.N126BE" class="para">11</a>] </sup>Gradle supports partial multiproject builds (see <a class="xref" href="multi_project_builds.html">Chapter&nbsp;25, <i>Multi-project Builds</i></a>).</p></div><div class="footnote"><p><sup>[<a href="#N126DC" name="ftn.N126DC" class="para">12</a>] </sup>
                            <a class="ulink" href="http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-relationships.html" target="_top">http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-relationships.html</a>
                        </p></div><div class="footnote"><p><sup>[<a href="#N12C00" name="ftn.N12C00" class="para">13</a>] </sup>At <a class="ulink" href="http://ant.apache.org/ivy/history/latest-milestone/concept.html" target="_top">http://ant.apache.org/ivy/history/latest-milestone/concept.html</a> you can learn more about ivy patterns.
                    </p></div><div class="footnote"><p><sup>[<a href="#N12FA9" name="ftn.N12FA9" class="para">14</a>] </sup>If you want to shield your project from the downtimes of Maven Central things get more complicated. You
                    probably want to set-up a repository proxy for this. In an enterprise environment this is rather
                    common. For an open source project it looks like overkill.
                </p></div></div></div><div class="navfooter"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="logging.html" title="Logging - Gradle User Guide Version 3.2">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide Version 3.2">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="multi_project_builds.html" title="Multi-project Builds - Gradle User Guide Version 3.2">Next</a></div></div></div></body></html>