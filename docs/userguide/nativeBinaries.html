<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter&nbsp;54.&nbsp;Building native binaries</title><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="base.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="docs.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="userguide.css"><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"><link rel="home" href="userguide.html" title="Gradle User Guide"><link rel="up" href="userguide.html" title="Gradle User Guide"><link rel="prev" href="signing_plugin.html" title="Chapter&nbsp;53.&nbsp;The Signing Plugin"><link rel="next" href="build_lifecycle.html" title="Chapter&nbsp;55.&nbsp;The Build Lifecycle"></head><body><div class="navheader"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="signing_plugin.html" title="Chapter&nbsp;53.&nbsp;The Signing Plugin">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="build_lifecycle.html" title="Chapter&nbsp;55.&nbsp;The Build Lifecycle">Next</a></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 xmlns:xslthl="http://xslthl.sf.net"><a name="nativeBinaries"></a>Chapter&nbsp;54.&nbsp;Building native binaries</h1></div></div></div><div class="note"><p>
            The Gradle support for building native binaries is currently <a class="link" href="feature_lifecycle.html">incubating</a>. Please be aware that the DSL and other configuration may change in later Gradle versions.
        </p></div><p>
        The various native binary plugins add support for building native software components from C++, C, Objective-C, Objective-C++ and Assembler sources.
        While many excellent build tools exist for this space of software development, Gradle offers developers it's trademark power and flexibility
        together with the dependency management practices more traditionally found in the JVM development space.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native-binaries:tool-chain-support"></a>54.1.&nbsp;Tool chain support</h2></div></div></div><p>
            Gradle offers the ability to execute the same build using different tool chains. You can control which tool chain will be used to build
            by changing the operating system PATH to include the desired tool chain compiler. Alternatively, you can configure the tool chains directly,
            as described in the `Native Binary Variants` section, below.
        </p><p>
            The following tool chains are supported:
        </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><div class="table-contents"><table id="N157FA">
                <tr><td>Operating System</td><td>Tool Chain</td><td>Notes</td></tr>
            <tr>
                <td>Linux</td><td><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a></td> <td></td>
            </tr><tr>
                <td>Linux</td><td><a class="ulink" href="http://clang.llvm.org" target="_top">Clang</a></td><td></td>
            </tr><tr>
                <td>Mac OS X</td><td><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a></td><td>Using GCC distributed with XCode.</td>
            </tr><tr>
                <td>Mac OS X</td><td><a class="ulink" href="http://clang.llvm.org" target="_top">Clang</a></td><td>Using Clang distributed with XCode.</td>
            </tr><tr>
                <td>Windows</td><td><a class="ulink" href="http://www.microsoft.com/visualstudio/en-us" target="_top">Visual C++</a></td><td>Windows XP and later, Visual C++ 2010 and later.</td>
            </tr><tr>
                <td>Windows</td><td><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a></td><td>Windows XP and later, using GCC distributed with Cygwin.</td>
            </tr><tr>
                <td>Windows</td><td><a class="ulink" href="http://www.mingw.org/" target="_top">MinGW</a></td><td>Windows XP and later.</td>
            </tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N15851"></a>54.2.&nbsp;Component model</h2></div></div></div><p>
            A native binary project defines a set of <a class="ulink" href="../dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a> and <a class="ulink" href="../dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a> components,
            each of which Gradle maps to a number of <a class="ulink" href="../dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a> outputs.
            For each <code class="literal">executable</code> or <code class="literal">library</code> defined, Gradle adds a <a class="ulink" href="../javadoc/org/gradle/language/base/FunctionalSourceSet.html" target="_top"><code class="classname">FunctionalSourceSet</code></a> with the same name.
            Each of these functional source sets will contain a language-specific source set for each of the languages supported by the project.
        </p><p>
            To build either a static or shared native library binary,
            a <a class="ulink" href="../dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a> component is added to the <code class="literal">libraries</code> container.
            Each <code class="literal">library</code> component can produce at least one <a class="ulink" href="../dsl/org.gradle.nativebinaries.SharedLibraryBinary.html" target="_top"><code class="classname">SharedLibraryBinary</code></a>
            and at least one <a class="ulink" href="../dsl/org.gradle.nativebinaries.StaticLibraryBinary.html" target="_top"><code class="classname">StaticLibraryBinary</code></a>.
        </p><div class="example"><a name="cppLibraries"></a><p class="title"><b>Example&nbsp;54.1.&nbsp;Defining a library component</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">libraries {
    hello {}
}</pre></div></div><br class="example-break"><p>
            To build an executable binary,
            an <a class="ulink" href="../dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a> component is added to the <code class="literal">executables</code> container
            and associated with a set of sources.
        </p><div class="example"><a name="cppExecutables"></a><p class="title"><b>Example&nbsp;54.2.&nbsp;Defining executable components</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">executables {
    main {}
}</pre></div></div><br class="example-break"><p>
            In many cases, more than one native binary can be produced for a component.
            These binaries may vary based on the tool chain used to build, the compiler/linker flags supplied, the dependencies
            provided, or additional source files provided. Each native binary produced for a component is referred to as <code class="literal">variant</code>.
            Binary variants are discussed in detail below.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N158AA"></a>54.3.&nbsp;Tasks</h2></div></div></div><p>
            For each <a class="ulink" href="../dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a> that can be produced by a build,
            a single <em class="firstterm">lifecycle task</em> is constructed that can be used to create that binary, together with a set of other tasks that do the actual
            work of compiling, linking or assembling the binary.
        </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><div class="table-contents"><table id="N158B7">
                <tr><td>Component Type</td><td>Native Binary Type</td><td>Lifecycle task</td><td>Location of created binary</td></tr>
            <tr>
                <td><a class="ulink" href="../dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a></td><td><a class="ulink" href="../dsl/org.gradle.nativebinaries.ExecutableBinary.html" target="_top"><code class="classname">ExecutableBinary</code></a></td><td><code class="literal"><em class="replaceable"><code>$component.name</code></em>Executable</code></td><td><code class="filename"><em class="replaceable"><code>$buildDir</code></em>/binaries/<em class="replaceable"><code>$binary.name</code></em>/<em class="replaceable"><code>$component.name</code></em></code></td>
            </tr><tr>
                <td><a class="ulink" href="../dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a></td><td><a class="ulink" href="../dsl/org.gradle.nativebinaries.SharedLibraryBinary.html" target="_top"><code class="classname">SharedLibraryBinary</code></a></td><td><code class="literal"><em class="replaceable"><code>$component.name</code></em>SharedLibrary</code></td><td><code class="filename"><em class="replaceable"><code>$buildDir</code></em>/binaries/<em class="replaceable"><code>$binary.name</code></em>/lib<em class="replaceable"><code>$component.name</code></em>.so</code></td>
            </tr><tr>
                <td><a class="ulink" href="../dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a></td><td><a class="ulink" href="../dsl/org.gradle.nativebinaries.StaticLibraryBinary.html" target="_top"><code class="classname">StaticLibraryBinary</code></a></td><td><code class="literal"><em class="replaceable"><code>$component.name</code></em>StaticLibrary</code></td><td><code class="filename"><em class="replaceable"><code>$buildDir</code></em>/binaries/<em class="replaceable"><code>$binary.name</code></em>/<em class="replaceable"><code>$component.name</code></em>.a</code></td>
            </tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N1591A"></a>54.3.1.&nbsp;Working with shared libraries</h3></div></div></div><p>
                For each executable binary produced, the <code class="literal">cpp</code> plugin provides an <code class="literal">install${binary.name}</code> task,
                which creates a development install of the executable, along with the shared libraries it requires.
                This allows you to run the executable without needing to install the shared libraries in their final locations.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:languages"></a>54.4.&nbsp;Core language support: C, C++, Assembler, Objective-C and Objective-C++ </h2></div></div></div><p>
            Presently, Gradle supports building native binaries from any combination of C++, C, Assembler, Objective-C and Objective-C++ sources.
            A native binary project will contain one or more named <code class="literal">FunctionalSourceSet</code> instances (eg 'main', 'test', etc),
            each of which can contain <code class="literal">LanguageSourceSet</code>s containing C++, C, Assembler, Objective-C or Objective-C++ source files.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15931"></a>54.4.1.&nbsp;C++ sources</h3></div></div></div><p>
                C++ language support is provided by means of the <code class="literal">'cpp'</code> plugin.
            </p><div class="example"><a name="cppPlugin"></a><p class="title"><b>Example&nbsp;54.3.&nbsp;The 'cpp' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'cpp'</span></pre></div></div><br class="example-break"><p>
                C++ sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a>,
                which defines a set of C++ source files and optionally a set of exported header files (for a library).
                By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a> contains
                <code class="filename">.cpp</code> source files in <code class="filename">src/${name}/cpp</code>,
                and header files in <code class="filename">src/${name}/headers</code>.
            </p><p>
                While the <code class="literal">cpp</code> plugin defines these default locations for each <a class="ulink" href="../dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a>,
                it is possible to extend or override these defaults to allow for a different project layout.
            </p><div class="example"><a name="cppSourceSet"></a><p class="title"><b>Example&nbsp;54.4.&nbsp;C++ source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sources {
    main {
        cpp {
            source {
                srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/source"</span>
                include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"**/*.cpp"</span>
            }
        }
    }
}</pre></div></div><br class="example-break"><p>
                For a library named 'main', files in <code class="filename">src/main/headers</code> are considered the &ldquo;public&rdquo; or &ldquo;exported&rdquo; headers.
                Header files that should not be exported (but are used internally) should be placed inside the <code class="filename">src/main/cpp</code> directory (though be aware that
                such header files should always be referenced in a manner relative to the file including them).
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15974"></a>54.4.2.&nbsp;C sources</h3></div></div></div><p>
                C language support is provided by means of the <code class="literal">'c'</code> plugin.
            </p><div class="example"><a name="cPlugin"></a><p class="title"><b>Example&nbsp;54.5.&nbsp;The 'c' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'c'</span></pre></div></div><br class="example-break"><p>
                C sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a>,
                which defines a set of C source files and optionally a set of exported header files (for a library).
                By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a> contains
                <code class="filename">.c</code> source files in <code class="filename">src/${name}/c</code>,
                and header files in <code class="filename">src/${name}/headers</code>.
            </p><p>
                While the <code class="literal">c</code> plugin defines these default locations for each <a class="ulink" href="../dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a>,
                it is possible to extend or override these defaults to allow for a different project layout.
            </p><div class="example"><a name="cSourceSet"></a><p class="title"><b>Example&nbsp;54.6.&nbsp;C source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sources {
    hello {
        c {
            source {
                srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/source"</span>
                include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"**/*.c"</span>
            }
            exportedHeaders {
                srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/include"</span>
            }
        }
    }
}</pre></div></div><br class="example-break"><p>
                For a library named 'main', files in <code class="filename">src/main/headers</code> are considered the &ldquo;public&rdquo; or &ldquo;exported&rdquo; headers.
                Header files that should not be exported (but are used internally) should be placed inside the <code class="filename">src/main/c</code> directory (though be aware that
                such header files should always be referenced in a manner relative to the file including them).
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N159B7"></a>54.4.3.&nbsp;Assembler sources</h3></div></div></div><p>
                Assembly language support is provided by means of the <code class="literal">'assembler'</code> plugin.
            </p><div class="example"><a name="assemblerPlugin"></a><p class="title"><b>Example&nbsp;54.7.&nbsp;The 'assembler' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'assembler'</span></pre></div></div><br class="example-break"><p>
                Assembler sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.assembler.AssemblerSourceSet.html" target="_top"><code class="classname">AssemblerSourceSet</code></a>,
                which defines a set of Assembler source files.
                By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.assembler.AssemblerSourceSet.html" target="_top"><code class="classname">AssemblerSourceSet</code></a> contains
                <code class="filename">.s</code> source files under <code class="filename">src/${name}/asm</code>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N159DB"></a>54.4.4.&nbsp;Objective-C sources</h3></div></div></div><p>
                Objective-C language support is provided by means of the <code class="literal">'objective-c'</code> plugin.
            </p><div class="example"><a name="objectiveCPlugin"></a><p class="title"><b>Example&nbsp;54.8.&nbsp;The 'objective-c' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'objective-c'</span></pre></div></div><br class="example-break"><p>
                Objective-C sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.objectivec.ObjectiveCSourceSet.html" target="_top"><code class="classname">ObjectiveCSourceSet</code></a>,
                which defines a set of Objective-C source files.
                By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.objectivec.ObjectiveCSourceSet.html" target="_top"><code class="classname">ObjectiveCSourceSet</code></a> contains
                <code class="filename">.m</code> source files under <code class="filename">src/${name}/objectiveC</code>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N159FF"></a>54.4.5.&nbsp;Objective-C++ sources</h3></div></div></div><p>
                Objective-C++ language support is provided by means of the <code class="literal">'objective-cpp'</code> plugin.
            </p><div class="example"><a name="objectiveCppPlugin"></a><p class="title"><b>Example&nbsp;54.9.&nbsp;The 'objective-cpp' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'objective-cpp'</span></pre></div></div><br class="example-break"><p>
                Objective-C++ sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.objectivecpp.ObjectiveCppSourceSet.html" target="_top"><code class="classname">ObjectiveCppSourceSet</code></a>,
                which defines a set of Objective-C++ source files.
                By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.objectivecpp.ObjectiveCppSourceSet.html" target="_top"><code class="classname">ObjectiveCppSourceSet</code></a> contains
                <code class="filename">.mm</code> source files under <code class="filename">src/${name}/objectiveCpp</code>.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N15A23"></a>54.5.&nbsp;Configuring the compiler, assembler and linker</h2></div></div></div><p>
            Each binary to be produced is associated with a set of compiler and linker settings, which include command-line arguments as well as macro definitions.
            These settings can be applied to all binaries, an individual binary, or selectively to a group of binaries based on some criteria.
        </p><div class="example"><a name="allBinarySettings"></a><p class="title"><b>Example&nbsp;54.10.&nbsp;Settings that apply to all binaries</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">binaries.all {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Define a preprocessor macro for every binary</span>
    cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"NDEBUG"</span>

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Define toolchain-specific compiler and linker options</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in Gcc) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-O2"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-fno-access-control"</span>
        linker.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-Xlinker"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-S"</span>
    }
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/Zi"</span>
        linker.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/DEBUG"</span>
    }
}</pre></div></div><br class="example-break"><p>
            Each binary is associated with a particular <a class="ulink" href="../dsl/org.gradle.nativebinaries.toolchain.ToolChain.html" target="_top"><code class="classname">ToolChain</code></a>, allowing settings to be targeted based on
            this value.
        </p><p>
            It is easy to apply settings to all binaries of a particular type:
        </p><div class="example"><a name="allSharedLibraryBinarySettings"></a><p class="title"><b>Example&nbsp;54.11.&nbsp;Settings that apply to all shared libraries</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// For any shared library binaries built with Visual C++, define the DLL_EXPORT macro</span>
binaries.withType(SharedLibraryBinary) {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp) {
        cCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/Zi"</span>
        cCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"DLL_EXPORT"</span>
    }
}</pre></div></div><br class="example-break"><p>
            Furthermore, it is possible to specify settings that apply to all binaries produces for a particular <code class="literal">executable</code>
            or <code class="literal">library</code> component:
        </p><div class="example"><a name="componentBinarySettings"></a><p class="title"><b>Example&nbsp;54.12.&nbsp;Settings that apply to all binaries produced for the 'main' executable component</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">executables {
    main {
        binaries.all {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp) {
                assembler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/Zi"</span>
            } <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">else</span> {
                assembler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-g"</span>
            }
        }
    }
}</pre></div></div><br class="example-break"><p>
            The example above will apply the supplied configuration to all <code class="literal">executable</code> binaries built.
        </p><p>
            Similarly, settings can be specified to target binaries for a component that are of a particular type:
            eg all <code class="literal">shared libraries</code> for the <code class="literal">main library</code> component.
        </p><div class="example"><a name="sharedLibraryArgs"></a><p class="title"><b>Example&nbsp;54.13.&nbsp;Settings that apply only to shared libraries produced for the 'main' library component</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">libraries {
    main {
        binaries.withType(SharedLibraryBinary) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Define a preprocessor macro that only applies to shared libraries</span>
            cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"DLL_EXPORT"</span>
        }
    }
}</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:windows-resources"></a>54.6.&nbsp;Windows Resources</h2></div></div></div><p>
            When using the <a class="ulink" href="../dsl/org.gradle.nativebinaries.toolchain.VisualCpp.html" target="_top"><code class="classname">VisualCpp</code></a> tool chain, Gradle is able to compile Window Resource (<code class="literal">rc</code>)
            files and link them into a native binary. This functionality is provided by the <code class="literal">'windows-resources'</code> plugin.
        </p><div class="example"><a name="windowsResourcesPlugin"></a><p class="title"><b>Example&nbsp;54.14.&nbsp;The 'windows-resources' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'windows-resources'</span></pre></div></div><br class="example-break"><p>
            Windows resources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.rc.WindowsResourceSet.html" target="_top"><code class="classname">WindowsResourceSet</code></a>,
            which defines a set of Windows Resource source files.
            By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.rc.WindowsResourceSet.html" target="_top"><code class="classname">WindowsResourceSet</code></a> contains
            <code class="filename">.rc</code> source files under <code class="filename">src/${name}/rc</code>.
        </p><p>
            As with other source types, you can configure the location of the windows resources that should in included in the binary.
        </p><div class="example"><a name="windowsResourceSet"></a><p class="title"><b>Example&nbsp;54.15.&nbsp;Configuring the location of Windows resource sources</b></p><div class="example-contents"><p><code class="filename">build-resource-only-dll.gradle</code></p><pre class="programlisting">sources {
    helloRes {
        rc {
            source {
                srcDirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/hello/rc"</span>
            }
            exportedHeaders {
                srcDirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/hello/headers"</span>
            }
        }
    }
}</pre></div></div><br class="example-break"><p>
            You are able to construct a resource-only library by providing Windows Resource sources with no other language sources,
            and configure the linker as appropriate:
        </p><div class="example"><a name="resourceOnlyDll"></a><p class="title"><b>Example&nbsp;54.16.&nbsp;Building a resource-only dll</b></p><div class="example-contents"><p><code class="filename">build-resource-only-dll.gradle</code></p><pre class="programlisting">libraries {
    helloRes {
        binaries.all {
            rcCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/v"</span>
            linker.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/noentry"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/machine:x86"</span>
        }
    }
}</pre></div></div><br class="example-break"><p>
            The example above also demonstrates the mechanism of passing extra command-line arguments to the resource compiler.
            The <code class="literal">rcCompiler</code> extension is of type <a class="ulink" href="../dsl/org.gradle.nativebinaries.language.PreprocessingTool.html" target="_top"><code class="classname">PreprocessingTool</code></a>.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N15ABD"></a>54.7.&nbsp;Library Dependencies</h2></div></div></div><p>
            Dependencies for C++ projects are binary libraries that export header files. The header files are used during compilation, with the compiled
            binary dependency being used during the linking.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15AC2"></a>54.7.1.&nbsp;Dependencies within the same project</h3></div></div></div><p>
               A set of sources may depend on header files provided by another binary component within the same project.
               A common example is a native executable component that uses functions provided by a separate native library component.
           </p><p>
               Such a library dependency can be easily provided to source set associated with the <code class="literal">executable</code> component:
           </p><div class="example"><a name="cppSourceLibrary"></a><p class="title"><b>Example&nbsp;54.17.&nbsp;Providing a library dependency to the source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sources {
    main {
        cpp {
            lib libraries.hello
        }
    }
}</pre></div></div><br class="example-break"><p>
               Alternatively, a library dependency can be provided directly to the <code class="literal">ExecutableBinary</code> for the <code class="literal">executable</code>.
           </p><div class="example"><a name="cppBinaryLibrary"></a><p class="title"><b>Example&nbsp;54.18.&nbsp;Providing a library dependency to the binary</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">executables {
    main {
        binaries.all {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Each executable binary produced uses the 'hello' static library binary</span>
            lib libraries.hello.<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">static</span>
        }
    }
}</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15AE8"></a>54.7.2.&nbsp;Project Dependencies</h3></div></div></div><p>
                For a component produced in a different Gradle project, the notation is similar.
            </p><div class="example"><a name="cppProjectDependencies"></a><p class="title"><b>Example&nbsp;54.19.&nbsp;Declaring project dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":lib"</span>) {
    apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cpp"</span>
    libraries {
        main {}
    }
}

project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":exe"</span>) {
    apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cpp"</span>

    executables {
        main {}
    }

    sources {
        main {
            cpp {
                lib project: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':lib'</span>, library: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'main'</span>
            }
        }
    }
}</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:variants"></a>54.8.&nbsp;Native Binary Variants</h2></div></div></div><p>
            For each executable or library defined, Gradle is able to build a number of different native binary variants.
            Examples of different variants include debug vs release binaries, 32-bit vs 64-bit binaries, and binaries produced
            with different custom preprocessor flags.
        </p><p>
            Binaries produced by Gradle can be differentiated on
                <a class="link" href="nativeBinaries.html#native_binaries:build_type">build type</a>,
                <a class="link" href="nativeBinaries.html#native_binaries:platform">platform</a> and
                <a class="link" href="nativeBinaries.html#native_binaries:flavor">flavor</a>.
            For each of these 'variant dimensions', it is possible to specify a set of available values as well as target each component at
            one, some or all of these. For example, a plugin may define a range of support platforms, but you
            may choose to only target Windows-x86 for a particular component.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="native_binaries:build_type"></a>54.8.1.&nbsp;Build types</h3></div></div></div><p>
                A <code class="literal">build type</code> determines various non-functional aspects of a binary, such as whether debug information is included,
                or what optimisation level the binary is compiled with. Typical build types are 'debug' and 'release', but a project
                is free to define any set of build types.
            </p><div class="example"><a name="buildTypes"></a><p class="title"><b>Example&nbsp;54.20.&nbsp;Defining build types</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    buildTypes {
        debug
        release
    }
}</pre></div></div><br class="example-break"><p>
                If no build types are defined in a project, then a single, default build type called 'debug' is added.
            </p><p>
                For a build type, a Gradle project will typically define a set of compiler/linker flags per tool chain.
            </p><div class="example"><a name="buildTypeConfig"></a><p class="title"><b>Example&nbsp;54.21.&nbsp;Configuring debug binaries</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">binaries.all {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in Gcc &amp;&amp; buildType == buildTypes.debug) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-g"</span>
    }
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp &amp;&amp; buildType == buildTypes.debug) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'/Zi'</span>
        cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'DEBUG'</span>
        linker.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'/DEBUG'</span>
    }
}</pre></div></div><br class="example-break"><div class="note">
                At this stage, it is completely up to the build script to configure the relevant compiler/linker flags for each
                build type. Future versions of Gradle will automatically include the appropriate debug flags for any 'debug' build
                type, and may be aware of various levels of optimisation as well.
            </div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="native_binaries:platform"></a>54.8.2.&nbsp;Platform</h3></div></div></div><p>
                An executable or library can be built to run on different operating systems and cpu architectures, with a variant being
                produced for each platform. Gradle defines each OS/architecture combination as a <a class="ulink" href="../dsl/org.gradle.nativebinaries.platform.Platform.html" target="_top"><code class="classname">Platform</code></a>,
                and a project may define any number of platforms.
                If no platforms are defined in a project, then a single, default platform 'current' is added.
            </p><div class="note">
                Presently, a <code class="literal">Platform</code> consists of a defined operating system and architecture. As we continue to develop the
                native binary support in Gradle, the concept of Platform will be extended to include things like C-runtime version, Windows SDK, ABI, etc.
                Sophisticated builds may use the extensibility of Gradle to apply additional attributes to each platform, which can then be queried to
                specify particular includes, preprocessor macros or compiler arguments for a native binary.
            </div><div class="example"><a name="platforms"></a><p class="title"><b>Example&nbsp;54.22.&nbsp;Defining platforms</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    platforms {
        x8<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">6</span> {
            architecture <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"x86"</span>
        }
        x6<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">4</span> {
            architecture <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"x86_64"</span>
        }
        itanium {
            architecture <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"ia-64"</span>
        }
    }
}</pre></div></div><br class="example-break"><p>
                For a given variant, Gradle will attempt to find a <a class="ulink" href="../dsl/org.gradle.nativebinaries.toolchain.ToolChain.html" target="_top"><code class="classname">ToolChain</code></a> that is able to build
                for the target platform. Available tool chains are searched in the order defined.
                See the <a class="link" href="nativeBinaries.html#native_binaries:tool_chain">tool chain</a> section below for more details.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="native_binaries:flavor"></a>54.8.3.&nbsp;Flavor</h3></div></div></div><p>
                Each component can have a set of named <code class="literal">flavors</code>, and a separate binary variant can be produced for each flavor.
                While the <code class="literal">build type</code> and <code class="literal">target platform</code> variant dimensions have a defined meaning in Gradle,
                each project is free to define any number of flavors and apply meaning to them in any way.
            </p><p>
                An example of component flavors might differentiate between 'demo', 'paid' and 'enterprise' editions of the component,
                where the same set of sources is used to produce binaries with different functions.
            </p><div class="example"><a name="flavors"></a><p class="title"><b>Example&nbsp;54.23.&nbsp;Defining flavors</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    flavors {
        english
        french
    }
}

libraries {
    hello {
        binaries.all {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (flavor == flavors.french) {
                cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"FRENCH"</span>
            }
        }
        source sources.lib
    }
}</pre></div></div><br class="example-break"><p>
                In the example above, a library is defined with a 'english' and 'french' flavor. When compiling the 'french'
                variant, a separate macro is defined which leads to a different binary being produced.
            </p><p>
                If no flavor is defined for a component, then a single default flavor named 'default' is used.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15B72"></a>54.8.4.&nbsp;Selecting the build types, platforms and flavors for a component</h3></div></div></div><p>
                For a default component, Gradle will attempt to create a native binary variant for each and every combination of <code class="literal">buildType</code>,
                <code class="literal">platform</code> and <code class="literal">flavor</code> defined for the project. It is possible to override this on a per-component
                basis, by specifying the set of <code class="literal">targetBuildTypes</code>, <code class="literal">targetPlatforms</code> and/or <code class="literal">targetFlavors</code>.
            </p><div class="example"><a name="targets"></a><p class="title"><b>Example&nbsp;54.24.&nbsp;Targeting a component at particular platforms</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">executables {
    main {
        targetPlatforms <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"x86"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"x64"</span>
    }
}</pre></div></div><br class="example-break"><p>
                Here you can see that the <a class="ulink" href="../dsl/org.gradle.nativebinaries.TargetedNativeComponent.html#org.gradle.nativebinaries.TargetedNativeComponent:targetPlatforms(java.lang.String...)" target="_top"><code class="classname">TargetedNativeComponent.targetPlatforms()</code></a> method is used to
                select the set of platforms to target for <code class="literal">executables.main</code>.
            </p><p>
                A similar mechanism exists for selecting <a class="ulink" href="../dsl/org.gradle.nativebinaries.TargetedNativeComponent.html#org.gradle.nativebinaries.TargetedNativeComponent:targetBuildTypes(java.lang.String...)" target="_top"><code class="classname">TargetedNativeComponent.targetBuildTypes()</code></a>
                and <a class="ulink" href="../dsl/org.gradle.nativebinaries.TargetedNativeComponent.html#org.gradle.nativebinaries.TargetedNativeComponent:targetFlavors(java.lang.String...)" target="_top"><code class="classname">TargetedNativeComponent.targetFlavors()</code></a>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15BA9"></a>54.8.5.&nbsp;Building all possible variants</h3></div></div></div><p>
                When a set of build types, target platforms, and flavors is defined for a component,
                a <a class="ulink" href="../dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a> model element is created for every possible
                combination of these. However, in many cases it is not possible to build a particular variant, perhaps because
                no tool chain is available to build for a particular platform.
            </p><p>
                If a binary variant cannot be built for any reason, then the <a class="ulink" href="../dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a>
                associated with that variant will not be <code class="literal">buildable</code>. It is possible to use this property to create a task
                to generate all possible variants on a particular machine.
            </p><div class="example"><a name="buildable"></a><p class="title"><b>Example&nbsp;54.25.&nbsp;Building all possible variants</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task buildAllExecutables {
    dependsOn binaries.withType(ExecutableBinary).matching {
        it.buildable
    }
}</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:tool_chain"></a>54.9.&nbsp;Tool chains</h2></div></div></div><p>
            A single build may utilize different tool chains to build variants for different platforms. To this end,
            the core 'native-binary' plugins will attempt to locate and make available supported tool chains. However, the set
            of tool chains for a project may also be explicitly defined, allowing additional cross-compilers to be configured
            as well as allowing the install directories to be specified.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15BCD"></a>54.9.1.&nbsp;Defining tool chains</h3></div></div></div><p>
                The supported tool chain types are:
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.nativebinaries.toolchain.Gcc.html" target="_top"><code class="classname">Gcc</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.nativebinaries.toolchain.Clang.html" target="_top"><code class="classname">Clang</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.nativebinaries.toolchain.VisualCpp.html" target="_top"><code class="classname">VisualCpp</code></a></p></li></ul></div><div class="example"><a name="toolChains"></a><p class="title"><b>Example&nbsp;54.26.&nbsp;Defining tool chains</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    toolChains {
        visualCpp(VisualCpp) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Specify the installDir if Visual Studio cannot be located by default</span>
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// installDir "C:/Apps/Microsoft Visual Studio 10.0"</span>
        }
        gcc(Gcc) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Uncomment to use a GCC install that is not in the PATH</span>
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// path "/usr/bin/gcc"</span>
        }
        clang(Clang)
    }
}</pre></div></div><br class="example-break"><p>
                Each tool chain implementation allows for a certain degree of configuration (see the API documentation for more details).
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15BF1"></a>54.9.2.&nbsp;Using tool chains</h3></div></div></div><p>
                It is not necessary or possible to specify the tool chain that should be used to build.
                For a given variant, Gradle will attempt to locate a <a class="ulink" href="../dsl/org.gradle.nativebinaries.toolchain.ToolChain.html" target="_top"><code class="classname">ToolChain</code></a> that is able to build
                for the target platform. Available tool chains are searched in the order defined.
            </p><div class="note">
                When a platform does not define an architecture or operating system, the default target of the tool chain
                is assumed. So if a platform does not define a value for <code class="literal">operatingSystem</code>,
                Gradle will find the first available tool chain that can build for the specified <code class="literal">architecture</code>.
            </div><p>
                The core Gradle tool chains are able to target the following architectures out of the box. In each case, the tool chain
                will target the current operating system. See the next section for information on cross-compiling for other operating systems.
            </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><div class="table-contents"><table id="N15C05">
                    <tr><td>Tool Chain</td><td>Architectures</td></tr>
                <tr>
                    <td>GCC</td><td>x86, x86_64</td>
                </tr><tr>
                    <td>Clang</td><td>x86, x86_64</td>
                </tr><tr>
                    <td>Visual C++</td><td>x86, x86_64, ia-64</td>
                </tr></table></div></div><p>
                So for GCC running on linux, the supported target platforms are 'linux/x86' and 'linux/x86_64'.
                For GCC running on Windows via Cygwin, platforms 'windows/x86' and 'windows/x86_64' are supported.
                (The Cygwin runtime is not yet modelled as part of the Platform, but will be in the future.)
            </p><p>
                If no target platforms are defined for a project, then all binaries are built to target a default platform named 'current'.
                This default platform does not specify any <code class="literal">architecture</code> or <code class="literal">operatingSystem</code> value,
                hence using the default values of the first available tool chain.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15C2D"></a>54.9.3.&nbsp;Cross-compiling with GCC</h3></div></div></div><p>
                Cross-compiling is possible with the <a class="ulink" href="../dsl/org.gradle.nativebinaries.toolchain.Gcc.html" target="_top"><code class="classname">Gcc</code></a> and <a class="ulink" href="../dsl/org.gradle.nativebinaries.toolchain.Clang.html" target="_top"><code class="classname">Clang</code></a> tool chains,
                by programmatically adding support for additional target platforms.
                This is done using the <a class="ulink" href="../dsl/org.gradle.nativebinaries.toolchain.PlatformConfigurableToolChain.html" target="_top"><code class="classname">PlatformConfigurableToolChain</code></a> API.
                Each added <a class="ulink" href="../javadoc/org/gradle/nativebinaries/toolchain/TargetPlatformConfiguration.html" target="_top"><code class="classname">TargetPlatformConfiguration</code></a> defines support for a particular target platform,
                and supplies additional tool arguments that are required to target this platform.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:visual_studio"></a>54.10.&nbsp;Visual Studio IDE integration</h2></div></div></div><p>
            Gradle has the ability to generate Visual Studio project and solution files for the native components defined in your build.
            This ability is added by the <code class="literal">visual-studio</code> plugin. For a multi-project build, all projects with native components
            should have this plugin applied.
        </p><p>
            When the <code class="literal">visual-studio</code> plugin is applied, a task name <code class="literal">${component.name}VisualStudio</code> is created
            for each defined component. This task will generate a Visual Studio Solution file for the named component. This solution will include
            a Visual Studio Project for that component, as well as linking to project files for each depended-on binary.
        </p><p>
            The content of the generated visual studio files can be modified via programmatic hooks, provided by the <code class="literal">visualStudio</code>
            extension. Take a look at the 'visual-studio' sample, or see <a class="ulink" href="../dsl/org.gradle.ide.visualstudio.VisualStudioExtension.html#org.gradle.ide.visualstudio.VisualStudioExtension:projects" target="_top"><code class="classname">VisualStudioExtension.getProjects()</code></a>
            and <a class="ulink" href="../dsl/org.gradle.ide.visualstudio.VisualStudioExtension.html#org.gradle.ide.visualstudio.VisualStudioExtension:solutions" target="_top"><code class="classname">VisualStudioExtension.getSolutions()</code></a> for more details.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:cunit"></a>54.11.&nbsp;CUnit support</h2></div></div></div><p>
            The Gradle <code class="literal">cunit</code> plugin provides support for compiling and executing CUnit tests in your native-binary project.
            For each <a class="ulink" href="../dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a> and <a class="ulink" href="../dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a>
            defined in your project, Gradle will create a matching <a class="ulink" href="../dsl/org.gradle.nativebinaries.test.cunit.CUnitTestSuite.html" target="_top"><code class="classname">CUnitTestSuite</code></a> component,
            named <code class="literal">${component.name}Test</code>.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15C81"></a>54.11.1.&nbsp;CUnit sources</h3></div></div></div><p>
                Gradle will create a <a class="ulink" href="../dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a> named 'cunit' for each <a class="ulink" href="../dsl/org.gradle.nativebinaries.test.cunit.CUnitTestSuite.html" target="_top"><code class="classname">CUnitTestSuite</code></a> component
                in the project. This source set should contain the cunit test files for the component sources. Source files can be located in the conventional location
                (<code class="literal">src/${component.name}Test/cunit</code>) or can be configured like any other source set.
            </p><p>
                The job of initialising the CUnit test registry and executing the tests is performed by Gradle, via some generated CUnit launcher sources.
                Gradle will expect and call a function with the signature <code class="literal">void gradle_cunit_register()</code> that you can use to configure the
                actual CUnit suites and tests to execute.
            </p><div class="example"><a name="cunitSources"></a><p class="title"><b>Example&nbsp;54.27.&nbsp;Registering CUnit tests</b></p><div class="example-contents"><p><code class="filename">suite_operators.c</code></p><pre class="programlisting">#include &lt;CUnit/Basic.h&gt;
#include "gradle_cunit_register.h"
#include "test_operators.h"

int suite_init(void) {
    return 0;
}

int suite_clean(void) {
    return 0;
}

void gradle_cunit_register() {
    CU_pSuite pSuiteMath = CU_add_suite("operator tests", suite_init, suite_clean);
    CU_add_test(pSuiteMath, "test_plus", test_plus);
    CU_add_test(pSuiteMath, "test_minus", test_minus);
}</pre></div></div><br class="example-break"><div class="note">
                Due to this mechanism, your CUnit sources may not contain a <code class="literal">main</code> method since this will clash with the method provided by Gradle.
            </div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15CA6"></a>54.11.2.&nbsp;Building CUnit executables</h3></div></div></div><p>
                A <a class="ulink" href="../dsl/org.gradle.nativebinaries.test.cunit.CUnitTestSuite.html" target="_top"><code class="classname">CUnitTestSuite</code></a> component has an associated
                <a class="ulink" href="../dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a> or <a class="ulink" href="../dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a> component.
                For each <a class="ulink" href="../dsl/org.gradle.nativebinaries.ProjectNativeBinary.html" target="_top"><code class="classname">ProjectNativeBinary</code></a> configured for the main component, a matching
                <a class="ulink" href="../javadoc/org/gradle/nativebinaries/test/TestSuiteExecutableBinary.html" target="_top"><code class="classname">TestSuiteExecutableBinary</code></a> will be configured on the test suite component.
                These test suite binaries can be configured in a similar way to any other binary instance:
            </p><div class="example"><a name="cunitSources"></a><p class="title"><b>Example&nbsp;54.28.&nbsp;Registering CUnit tests</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">binaries.withType(TestSuiteExecutableBinary) {
    lib library: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cunit"</span>, linkage: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"static"</span>

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (flavor == flavors.failing) {
        cCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"PLUS_BROKEN"</span>
    }
}</pre></div></div><br class="example-break"><div class="note">
                Both the CUnit sources provided by your project and the generated launcher require the core CUnit headers and libraries.
                Presently, this library dependency must be provided by your project for each <a class="ulink" href="../javadoc/org/gradle/nativebinaries/test/TestSuiteExecutableBinary.html" target="_top"><code class="classname">TestSuiteExecutableBinary</code></a>.
            </div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15CD5"></a>54.11.3.&nbsp;Running CUnit tests</h3></div></div></div><p>
                For each <a class="ulink" href="../javadoc/org/gradle/nativebinaries/test/TestSuiteExecutableBinary.html" target="_top"><code class="classname">TestSuiteExecutableBinary</code></a>, Gradle will create a task to execute this binary,
                which will run all of the registered CUnit tests.
                The generated test results will be located in the <code class="literal"><em class="replaceable"><code>${build.dir}</code></em>/test-results</code> directory.
            </p><div class="example"><a name="completeCUnitExample"></a><p class="title"><b>Example&nbsp;54.29.&nbsp;Running CUnit tests</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"c"</span>
apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cunit"</span>

model {
    flavors {
        passing
        failing
    }
    repositories {
        libs(PrebuiltLibraries) {
            cunit {
                headers.srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"lib/cunit/2.1-2/include"</span>
                binaries.withType(StaticLibraryBinary) {
                    staticLibraryFile = file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"lib/cunit/2.1-2/lib/"</span> + findCUnitLibForPlatform(targetPlatform))
                }
            }
        }
    }
}

libraries {
    operators {}
}
binaries.withType(TestSuiteExecutableBinary) {
    lib library: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cunit"</span>, linkage: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"static"</span>

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (flavor == flavors.failing) {
        cCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"PLUS_BROKEN"</span>
    }
}</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/native-binaries/cunit</code> which is in both the binary and source distributions of Gradle.</p></div></div></div><br class="example-break"><pre class="screen">&gt; gradle -q runFailingOperatorsTestCUnitExe

There were test failures:
  1. /home/user/gradle/samples/native-binaries/cunit/src/operatorsTest/cunit/test_plus.c:6  - plus(0, -2) == -2
  2. /home/user/gradle/samples/native-binaries/cunit/src/operatorsTest/cunit/test_plus.c:7  - plus(2, 2) == 4

:runFailingOperatorsTestCUnitExe FAILED

BUILD FAILED

Total time: 1 secs</pre></div><div class="note"><p>
                The current support for CUnit is quite rudimentary. Plans for future integration include:
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Allow tests to be declared with javadoc-style annotations.</p></li><li class="listitem"><p>Improved HTML reporting, similar to that available for JUnit.</p></li><li class="listitem"><p>Real-time feedback for test execution.</p></li><li class="listitem"><p>Support for additional test frameworks.</p></li></ul></div></div></div></div><div class="navfooter"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="signing_plugin.html" title="Chapter&nbsp;53.&nbsp;The Signing Plugin">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="build_lifecycle.html" title="Chapter&nbsp;55.&nbsp;The Build Lifecycle">Next</a></div></div></div></body></html>